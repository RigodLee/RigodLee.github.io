{"meta":{"title":"shadow","subtitle":"","description":"","author":"shadow","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2020-06-07T11:52:05.000Z","updated":"2020-07-24T09:27:41.372Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Gallery","date":"2020-07-24T08:25:19.000Z","updated":"2020-07-28T07:04:47.357Z","comments":false,"path":"gallery/index.html","permalink":"http://yoursite.com/gallery/index.html","excerpt":"","text":"壁纸 收藏的一些壁纸 虞书欣 虞书欣全屏壁纸"},{"title":"music","date":"2020-06-16T04:34:19.000Z","updated":"2020-06-16T06:26:48.453Z","comments":true,"path":"music/index.html","permalink":"http://yoursite.com/music/index.html","excerpt":"","text":"var ap = new APlayer({ element: document.getElementById(\"aplayer-cmEZqKfZ\"), narrow: false, autoplay: true, showlrc: false, music: { title: \"绝对是个梦\", author: \"汤宝如\", url: \"http://music.163.com/song/media/outer/url?id=295844.mp3\", pic: \"http://p1.music.126.net/NvP0E5Ej94EQ1K3MbH7L3w==/18168330138187688.jpg?param=130y130\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); var options = {\"narrow\":false,\"autoplay\":true,\"showlrc\":3,\"mode\":\"random\",\"music\":[{\"title\":\"情人知己\",\"author\":\"叶倩文\",\"url\":\"http://music.163.com/song/media/outer/url?id=5258720.mp3\",\"pic\":\"http://p2.music.126.net/5yc6IEb-zl6GNNt9fY6g4g==/37383395361212.jpg?param=130y130\",\"lrc\":\"http://og9ocpmwk.bkt.clouddn.com/%E5%B9%B3%E5%87%A1%E4%B9%8B%E8%B7%AF.txt\"},{\"title\":\"梦伴\",\"author\":\"李悦君\",\"url\":\"http://music.163.com/song/media/outer/url?id=26584453.mp3\",\"pic\":\"http://p1.music.126.net/KWonqfsj39pd5_Yyf2bE6g==/109951163856433553.jpg?param=130y130\",\"lrc\":\"https://ogd99kckh.qnssl.com/%E9%87%8E%E5%AD%90.txt\"},{\"title\":\"一休\",\"author\":\"陈柏宇\",\"url\":\"http://music.163.com/song/media/outer/url?id=25918369.mp3\",\"pic\":\"http://p2.music.126.net/RzhGu8CU8i6cyj8mvaAXzQ==/18854425393134490.jpg?param=130y130\",\"lrc\":\"https://ogd99kckh.qnssl.com/%E9%87%8E%E5%AD%90.txt\"}]}; options.element = document.getElementById(\"aplayer-ooqdCKIV\"); var ap = new APlayer(options); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);"},{"title":"标签","date":"2020-06-07T11:50:14.000Z","updated":"2020-07-24T09:29:42.277Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-07-24T09:25:19.000Z","updated":"2020-07-24T13:05:08.865Z","comments":true,"path":"messageboard/index.html","permalink":"http://yoursite.com/messageboard/index.html","excerpt":"","text":"⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⡖⠀⠀⠀⠀⠀⠀⠀⣀⡀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢈⣿⡷⠀⠀⠀⢠⣾⣿⡿⠋⠁⠀ ⠀⠀⠀⠀⣠⠔⠚⣋⠉⠛⠒⢾⣿⠟⠁⠀⠀⠀⠘⣿⣿⠁⠀⠀⠀ ⠀⠀⢀⠞⢡⣴⣶⠏⠣⠤⢤⡀⠹⡄⠀⣀⣤⣶⣾⣿⣿⡇⠀⠀⠀ ⠀⠀⢸⢀⣸⣽⡅⢰⢦⣳⡄⠈⢦⢹⣾⣿⣿⣿⣿⡿⠟⠁⠀⠀⠀ ⠀⢀⣸⠈⢹⣿⣮⠉⣥⢍⣳⣠⣼⣼⡿⠟⠉⠀⠀⠀⠀⠀⢠⣤⡄ ⢰⣿⣯⣦⢸⡋⠋⠀⠉⠀⠙⣿⣿⠛⠓⢄⠤⣤⣀⡤⣄⣀⣿⣿⣷ ⠴⢿⡋⠀⠑⢷⣭⣀⣠⣤⣾⣿⡇⠀⠀⠀⠈⠁⠀⠀⡏⢿⣹⡧⠃ ⠀⠀⠑⠤⢤⡀⢏⠻⣿⣿⣿⣅⡇⠹⣄⣀⣀⣀⣀⣠⠟⠉⠀⠀⠀ ⠀⠀⠀⠀⠀⠘⠺⢦⠀⠻⣿⣏⠀⠀⠀⠀⠀⠀⠈⠲⢤⣀⠀⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠑⢄⠘⢿⣷⡄⠀⠀⠀⠀⠀⠀⠀⠈⣗⠀⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢦⣙⠻⣧⡀⠀⠀⠀⠀⠀⢀⣿⣷⣦"},{"title":"友链","date":"2020-06-07T11:53:53.000Z","updated":"2020-10-02T04:20:17.318Z","comments":true,"path":"link/index.html","permalink":"http://yoursite.com/link/index.html","excerpt":"","text":"我的Blog资料Blog 名字： shadow Blog 地址： https://shadowx.vip/ Blog 头像： https://s1.ax1x.com/2020/07/26/a9aLss.png Blog 简介： 念念不忘，必有回响 友链申请 请先添加本站为友链后再申请友链，并通过留言或邮件告知 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的全站 HTTPS 站点交换 不接受视频站、资源站等非博客类站点交换，原则上只与技术/日志类博客交换友链 新站点（建站时间不超过三个月）请维护一段时间后再来申请，不接受一时起兴的博客 加入友链后会在本站任意留言区获得小伙伴徽章（以邮箱判定）一枚哦"},{"title":"关于自己","date":"2020-07-24T13:25:19.000Z","updated":"2020-08-08T15:06:21.170Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"$hadow 🍀 个人简介 大三 后台方向、技术菜鸟 水平有限，在博客分享的内容可能有错，希望指出 🔍 🌌 博客简介 全站 HTTPS Hexo 框架 + Butterfly 主题 博客中的部分图片源于网络，侵删 本博客文章采用 CC BY-NC-SA 4.0 协议 协议，转载请注明出处 🔑 技能学习 Java SSM（学习中） Bootstrap、layui HTML、CSS3、JavaScript（学习中） 🌟 待掌握技能 Spring boot ..."},{"title":"壁纸","date":"2020-07-24T08:25:19.000Z","updated":"2020-07-28T05:03:58.161Z","comments":false,"path":"gallery/wallpaper/index.html","permalink":"http://yoursite.com/gallery/wallpaper/index.html","excerpt":"","text":""},{"title":"虞书欣","date":"2020-07-28T08:25:19.000Z","updated":"2020-07-28T04:48:46.500Z","comments":false,"path":"gallery/esther/index.html","permalink":"http://yoursite.com/gallery/esther/index.html","excerpt":"","text":""}],"posts":[{"title":"解决SpringBoot的properties文件值注入出现中文乱码","slug":"解决SpringBoot的properties文件值注入出现中文乱码","date":"2020-10-01T12:19:09.858Z","updated":"2020-10-01T12:23:27.544Z","comments":true,"path":"2020/10/01/解决SpringBoot的properties文件值注入出现中文乱码/","link":"","permalink":"http://yoursite.com/2020/10/01/%E8%A7%A3%E5%86%B3SpringBoot%E7%9A%84properties%E6%96%87%E4%BB%B6%E5%80%BC%E6%B3%A8%E5%85%A5%E5%87%BA%E7%8E%B0%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/","excerpt":"","text":"","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"Butterfly主题Valine评论美化","slug":"Butterfly主题Valine评论美化","date":"2020-10-01T07:49:34.736Z","updated":"2020-10-01T12:17:42.803Z","comments":true,"path":"2020/10/01/Butterfly主题Valine评论美化/","link":"","permalink":"http://yoursite.com/2020/10/01/Butterfly%E4%B8%BB%E9%A2%98Valine%E8%AF%84%E8%AE%BA%E7%BE%8E%E5%8C%96/","excerpt":"","text":"今天把Butterfly主题从2.3.5更新到3.2.0后，原本的Valine评论美化没了。幸好提前备份了文件，不过3.x.x后Valine的文件路径发生了变动，写这篇文章记录一下Valine的样式美化。 在 veditor 输入界面增加背景图使用方法如下，将CSS加到博客样式文件中，文件路径如下：X:\\XX\\HexoBlog\\themes\\Butterfly\\source\\css\\index.styl 12345678#veditor &#123; background-image: url(https://image.bestzuo.cn/images/20200708160947.gif!getwebp); background-size: contain; background-repeat: no-repeat; background-position: right; background-color: rgba(255, 255, 255, 0); resize: vertical&#125; url 内的图片可以换成自己的图片。可以设置当鼠标聚焦于输入框时，背景图消失，输入框失去焦点时，背景图重新显示，代码如下： 1234#veditor:focus&#123; background-position-y: 200px; transition: all 0.2s ease-in-out 0s;&#125; 其中的 200px 差不多代表了图片的高度，transition 中的 0.2s 代表了消失的时间，可以根据自己的图片进行调整。 增加博主、小伙伴标识以及浏览器图标 原生的 Valine 不支持这个美化，所以需要使用魔改的 Valine 文件，在配置文件中搜索Valine，将原来的js替换成魔改版 12//魔改版 Valine.min.jshttps://cdn.jsdelivr.net/gh/HCLonely/Valine@latest/dist/Valine.min.js 与原生的相比，魔改版多了以下功能：①添加博主，小伙伴，访客标签②添加浏览器和操作系统图标，需引入 fontawesome v5.0+ 的 CSS 样式③邮箱检测更严格④增加 QQ 邮箱识别（原版只能通过昵称栏输入 QQ 号识别）⑤meta placeholder 可自定义使用方法与原生的类似，不同的是可以多设置几个参数：| 参数 | 类型 | 说明 | 默认 | 示例 || —— | —— | —— | —— | —— || tagMeta | Array | 标签要显示的文字 | [“博主”,“小伙伴”,“访客”] | [“博主”,”小伙伴”,”访客”] || master | Array/String | md5 加密后的博主邮箱 | [] | [“fe01ce2a7fbac8fafaed7c982a04e229”] || friends | Array/String | md5 加密后的博主邮箱 | [] | [“fe01ce2a7fbac8fafaed7c982a04e229”] || metaPlaceholder | Object | meta placeholder 内容 | {} | {“nick”:“昵称 / QQ 号”,“mail”:“邮箱 (必填)”} || verify | Boolean | 评论时是否需要验证，需 jQuery 支持 | false | true | 示例2.x.x版本修改X:\\XX\\HexoBlog\\themes\\Butterfly\\layout\\includes\\comments\\valine.pug 3.x.x版本修改X:\\XX\\HexoBlog\\themes\\Butterfly\\layout\\includes\\third-party\\comments\\valine.pug","categories":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Valine","slug":"Valine","permalink":"http://yoursite.com/tags/Valine/"}]},{"title":"【SSM框架入门】springMVC配置解决post中文乱码的过滤器和解决get请求中文乱码","slug":"【SSM框架入门】springMVC配置解决post中文乱码的过滤器和解决get请求中文乱码","date":"2020-09-23T09:55:12.908Z","updated":"2020-09-23T09:57:25.394Z","comments":true,"path":"2020/09/23/【SSM框架入门】springMVC配置解决post中文乱码的过滤器和解决get请求中文乱码/","link":"","permalink":"http://yoursite.com/2020/09/23/%E3%80%90SSM%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E3%80%91springMVC%E9%85%8D%E7%BD%AE%E8%A7%A3%E5%86%B3post%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E8%A7%A3%E5%86%B3get%E8%AF%B7%E6%B1%82%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/","excerpt":"","text":"1. 解决post请求乱码在web.xml配置文件中配置过滤器 12345678910111213&lt;!-- 配置解决中文乱码的过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 后台输出中文乱码解决 2. 解决get请求乱码修改Tomcat（Tomcat7）的conf目录下的配置文件server.xml，在Connector标签下添加“URIEncoding=”UTF-8“”输出结果","categories":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/categories/SSM/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"},{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/tags/SSM/"}]},{"title":"【SSM框架入门】springMVC环境搭建与入门案例","slug":"【SSM框架入门】springMVC环境搭建与入门案例","date":"2020-09-23T09:55:09.336Z","updated":"2020-09-23T09:57:03.012Z","comments":true,"path":"2020/09/23/【SSM框架入门】springMVC环境搭建与入门案例/","link":"","permalink":"http://yoursite.com/2020/09/23/%E3%80%90SSM%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E3%80%91springMVC%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/","excerpt":"","text":"环境搭建1. 创建一个web项目如果项目创建过慢，可以在创建的时候输入该键值对“archetypeCatalog : internal” 2. 完善目录结构创建完项目，此时的目录结构是不完善的。所以要自行创建一个java目录，并把该目录指定为“Sources Root”如果创建完项目，目录中没有resources。也要自行创建一个resources目录，并把该目录指定为“Resources Root” 3. 导入坐标12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;springMVC&lt;/name&gt; &lt;groupId&gt;com.ssm&lt;/groupId&gt; &lt;artifactId&gt;springMVC&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 版本锁定 --&gt; &lt;properties&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 4. 配置springMVC前端控制器123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;!-- /表示发任何的请求都经过这个servlet --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 5. 创建配置文件 9. 配置Tomcat这里需要先下载Tomcat并配置环境变量，然后打开Run —&gt; Edit Configurations，点击+号找到Tomcat Server —&gt; Local（若是没有找到Tomcat Server 可以点击最后一行 34 items more）点击Configuration ，找到本地 Tomcat 服务器点击Deployment ，点击+号把项目部署到服务器，配置路径名，再点击OK按钮 入门案例1. 新建一个jsp页面12345678910&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;Hello World&lt;/h3&gt; &lt;a href=\"hello\"&gt;入门案例&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 2. 新建一个controller 3. 编写springmvc.xml的配置文件1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package=\"com.springMVC\"&gt;&lt;/context:component-scan&gt; &lt;/beans&gt; 4. 给HelloController添加注解将HelloController交由spring管理，使用@RequestMapping注解配置映射请求 5. 配置web.xml加载springmvc.xml 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app version=\"2.4\" xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\"&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- load-on-startup 元素标记容器是否应该在web应用程序启动的时候就加载这个servlet，(实例化并调用其init()方法)。 它的值必须是一个整数，表示servlet被加载的先后顺序。 如果该元素的值为负数或者没有设置，则容器会当Servlet被请求时再加载。 如果值为正整数或者0时，表示容器在应用启动时就加载并初始化这个servlet，值越小，servlet的优先级越高，就越先被加载。值相同时，容器就会自己选择顺序来加载。 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;!-- /表示发任何的请求都经过这个servlet --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 6. 创建pages目录，在目录下新建一个success.jsp 7. 在springmvc.xml配置视图解析器1234567&lt;!-- 视图解析器对象 --&gt; &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!-- 配置jsp所在目录 --&gt; &lt;property name=\"prefix\" value=\"pages/\"/&gt; &lt;!-- 配置jsp的后缀名 --&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; 8. 运行结果点击超链接会在后台打印“Hello springMVC”，并跳转到success.jsp","categories":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/categories/SSM/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"},{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/tags/SSM/"}]},{"title":"【SSM框架入门】spring基于xml配置AOP","slug":"【SSM框架入门】spring基于xml配置AOP","date":"2020-09-23T09:55:06.535Z","updated":"2020-09-23T10:07:28.243Z","comments":true,"path":"2020/09/23/【SSM框架入门】spring基于xml配置AOP/","link":"","permalink":"http://yoursite.com/2020/09/23/%E3%80%90SSM%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E3%80%91spring%E5%9F%BA%E4%BA%8Exml%E9%85%8D%E7%BD%AEAOP/","excerpt":"","text":"1. 创建一个maven项目1.1 导入jar包123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.spring&lt;/groupId&gt; &lt;artifactId&gt;springAop&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 解析切入点表达式 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 1.2 创建模拟操作账户的接口和实现类1234567891011121314151617181920212223package com.springAoc.service;/** * 账户的业务层接口 */public interface IAccountService &#123; /** * 模拟保存账户 */ void saveAccount(); /** * 模拟更新账户 * @param i */ void updateAccount(int i); /**模拟删除账户 * @return */ int deleteAccount();&#125; 123456789101112131415161718package com.springAoc.service.impl;import com.springAoc.service.IAccountService;public class AccountServiceImpl implements IAccountService &#123; public void saveAccount() &#123; System.out.println(\"执行了保存操作\"); &#125; public void updateAccount(int i) &#123; System.out.println(\"执行了更新操作\"+i); &#125; public int deleteAccount() &#123; System.out.println(\"执行了删除操作\"); return 0; &#125;&#125; 3. 创建一个公共日志类，用于AOP的前置增强1234567891011121314package com.springAoc.utils;/** * 用于记录日记的工具类，它里面提供了公共的代码 */public class Logger &#123; /** * 用于打印日志，计划让其在切入点方法执行之前执行（切入点方法就是业务层方法） */ public void printLog()&#123; System.out.println(\"Logger类中的printLog方法开始记录日志。。。\"); &#125;&#125; 4. 创建bean配置文件在配置文件中导入aop的约束，配置AccountServiceImpl和日志类Logger的bean，放入spring容器。使用&lt;aop:config&gt;标签配置切面 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!-- 配置spring的Ioc，把service对象配置进来 --&gt; &lt;bean id=\"accountService\" class=\"com.springAop.service.impl.AccountServiceImpl\"&gt;&lt;/bean&gt; &lt;!-- spring基于xml的AOP配置步骤 1、把增强bean也交给spring管理 2、使用aop:config标签表明开始AOP的配置 3、使用aop:aspect标签表明配置切面 id属性：是给切面提供一个唯一标识 ref属性：是指定增强类bean的id 4、在aop:aspect标签的内部使用对应标签来配置增强的类型 我们现在的示例是让printLog方法在切入点方法执行之前执行，所以是前置增强 aop:before：表示配置前置增强 method：用于指定Logger类中哪个方法是前置增强 pointcut属性：用于指定切入点表达式，该表达式的含义指的是对业务层中哪些方法增强 切入点表达式的写法： 关键字：execution（表达式） 表达式：访问修饰符 返回值 包名.类名.方法名（参数列表） --&gt; &lt;!-- 配置Logger类 --&gt; &lt;bean id=\"logger\" class=\"com.springAop.utils.Logger\"&gt;&lt;/bean&gt; &lt;!-- 配置AOP --&gt; &lt;aop:config&gt; &lt;!-- 配置切面 --&gt; &lt;aop:aspect id=\"logAdvice\" ref=\"logger\"&gt; &lt;!-- 配置增强的类型，并且建立增强方法和切入点方法的关联 --&gt; &lt;aop:before method=\"printLog\" pointcut=\"execution(public void com.springAop.service.impl.AccountServiceImpl.saveAccount())\"&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 5. 新建一个测试类12345678910111213141516package com.springAop.test;import com.springAop.service.IAccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class aopTest &#123; public static void main(String[] args) &#123; //1.获取容器 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); //2.获取对象 IAccountService as = (IAccountService)ac.getBean(\"accountService\"); //3.执行方法 as.saveAccount(); &#125;&#125; 6. 运行结果 8. 配置四个增强（前置、后置、异常、最终）8.1 修改日志Logger类123456789101112131415161718192021222324252627282930313233343536package com.springAop.utils;/** * 用于记录日记的工具类，它里面提供了公共的代码 */public class Logger &#123; /** * 用于打印日志，计划让其在切入点方法执行之前执行（切入点方法就是业务层方法） * 前置增强 */ public void beforePrintLog()&#123; System.out.println(\"前置增强————Logger类中的beforePrintLog方法开始记录日志。。。\"); &#125; /** * 后置增强 */ public void afterReturnPrintLog()&#123; System.out.println(\"后置增强————Logger类中的afterReturnPrintLog方法开始记录日志。。。\"); &#125; /** * 异常增强 */ public void afterThrowingPrintLog()&#123; System.out.println(\"异常增强————Logger类中的afterThrowingPrintLog方法开始记录日志。。。\"); &#125; /** * 最终增强 */ public void afterPrintLog()&#123; System.out.println(\"最终增强————Logger类中的afterPrintLog方法开始记录日志。。。\"); &#125;&#125; 8.2 修改配置文件12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!-- 配置spring的Ioc，把service对象配置进来 --&gt; &lt;bean id=\"accountService\" class=\"com.springAop.service.impl.AccountServiceImpl\"&gt;&lt;/bean&gt; &lt;!-- 配置Logger类 --&gt; &lt;bean id=\"logger\" class=\"com.springAop.utils.Logger\"&gt;&lt;/bean&gt; &lt;!-- 配置AOP --&gt; &lt;aop:config&gt; &lt;!-- 配置切面 --&gt; &lt;aop:aspect id=\"logAdvice\" ref=\"logger\"&gt; &lt;!-- 配置增强的类型，并且建立增强方法和切入点方法的关联 --&gt; &lt;!-- 配置前置增强 --&gt; &lt;aop:before method=\"beforePrintLog\" pointcut=\"execution(* com.springAop.service.impl.*.*(..))\"&gt;&lt;/aop:before&gt; &lt;!-- 配置后置增强 --&gt; &lt;aop:after-returning method=\"afterReturnPrintLog\" pointcut=\"execution(* com.springAop.service.impl.AccountServiceImpl.*(..))\"&gt;&lt;/aop:after-returning&gt; &lt;!-- 配置异常增强 --&gt; &lt;aop:after-throwing method=\"afterThrowingPrintLog\" pointcut=\"execution(* com.springAop.service.impl.AccountServiceImpl.*(..))\"&gt;&lt;/aop:after-throwing&gt; &lt;!-- 配置最终增强 --&gt; &lt;aop:after method=\"afterPrintLog\" pointcut=\"execution(* com.springAop.service.impl.AccountServiceImpl.*(..))\"&gt;&lt;/aop:after&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 8.3 运行结果 8.4 异常运行结果在实现类中加入一个异常此时就没有后置增强，只有异常增强 9. 切入点表达式的写法关键字：execution（表达式）表达式：访问修饰符 返回值 包名.类名.方法名（参数列表）示例public void com.springAop.service.impl.AccountServiceImpl.saveAccount()访问修饰符可以省略void com.springAop.service.impl.AccountServiceImpl.saveAccount()返回值可以使用通配符，表示任意返回值* com.springAop.service.impl.AccountServiceImpl.saveAccount()包名可以使用通配符，表示任意包，有几级包就要写几个*.* *.*.*.*.AccountServiceImpl.saveAccount()包名可以使用. .表示当前包及其子包* *. .AccountServiceImpl.saveAccount()类名和方法名都可以用使用*来实现通配* *. .*.*()方法参数列表可以直接写数据类型：———— 基本类型直接写名称： int———— 引用类型写包名.类名的方式：java.lang.String可以使用通配符表示任意类型，但是必须有参数可以使用. .表示有无参数均可，有参数可以是任意类型全通配写法* *. .*.*(. .)实际开发中切入点表达式的通常写法切到业务层实现类下的所有方法* com.springAop.service.impl.*.*（. .） 10. 切入点表达式简化当我们给同一个方法配置多个增强的时候，会出现重复的切入点表达式。此时可以使用aop增强标签中的pointcut-ref属性，简化切入点表达式 10.1 配置切入点表达式，id属性用于指定表达式的唯一标识，expression属性用于指定表达式内容10.2 把aop增强标签中的pointcut属性换成point-ref属性&lt;aop:pointcut&gt;标签写在&lt;aop:aspect&gt;标签内只能当前切面使用，它还可以写在&lt;aop:aspect&gt;标签外，此时就变成了所有切面可用，但是要写在&lt;aop:aspect&gt;标签的前面，这是spring规定的标签顺序","categories":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/categories/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/tags/SSM/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"【SSM框架入门】spring中常用的IOC注解按照作用分类","slug":"【SSM框架入门】spring中常用的IOC注解按照作用分类","date":"2020-09-23T09:55:03.886Z","updated":"2020-09-23T10:07:43.761Z","comments":true,"path":"2020/09/23/【SSM框架入门】spring中常用的IOC注解按照作用分类/","link":"","permalink":"http://yoursite.com/2020/09/23/%E3%80%90SSM%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E3%80%91spring%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84IOC%E6%B3%A8%E8%A7%A3%E6%8C%89%E7%85%A7%E4%BD%9C%E7%94%A8%E5%88%86%E7%B1%BB/","excerpt":"","text":"1. 用于创建对象：它们的作用和在xml配置文件中编写一个&lt;bean&gt;标签实现的功能是一样的 1.1 @Component作用：用于把当前类对象存入spring容器中属性：value（用于指定bean的id，当我们不写时，它的默认值时当前类名，且首字母改小写） 1.2 @Controller1.3 @Service1.4 @Repository以上三个注解它们的作用和属性与Conpoment是一模一样的，它们三个是spring框架提供明确的三层使用的注解，使我们的三层对象更加清晰。“Controller”一般用在表现层，“Service”一般用在业务层，“Repository”一般用在持久层 2. 用于注入数据：它们的作用和在xml配置文件中的bean标签中写ー个&lt;property&gt;标签的作用是一样的 2.1 @Autowired作用：自动按照类型注入，只要容器中有唯一的一个bean对象类型和要注入的变量类型匹配，就可以注入成功；如果IOC容器中没有任何bean的类型和要注入的变量类型匹配，则报错。如果IOC容器中有多个类型匹配时，则需要通过变量名作为bean的id去匹配相应的类出现位置：可以是变量上，也可以是方法上细节：在使用注解注入时，set方法就不是必须的了 2.2 @Qualifier作用：在按照类中注入的基础之上再按照名称注入，它在给类成员注入时不能单独使用，但是在给方法参数注入时可以属性：value（用于指定注入bean的id） 2.3 @Resource作用：直接按照bean的id注入，它可以独立使用，不需要@Autowired属性：name（用于指定bean的id） 以上三个注入都只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现，另外集合类型的注入只能通过XML实现 2.4 @Value作用：用于注入基本类型和String类型的数据属性：value（用于指定数据的值，它可以使用spring中SpEL，也就是spring的el表达式）SpEl的写法：${表达式} 3. 用于改变作用范围：它们的作用和在bean标签中使用 scope属性实现的功能是一样的 3.1 @Scope作用：和在bean标签中使用scope属性实现的功能是一样的属性：value（用于指定范围的取值，常用的取值有singleton和prototype） 4. 和生命周期相关：它们的作用就和在bean标签中使用init-method和destroy-method的作用是一样的 4.1 @PostConstruct作用：用于指定初始化方法 4.2 @PreDestroy作用：用于指定销毁方法","categories":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/categories/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/tags/SSM/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"【SSM框架入门】spring创建bean的三种方式和依赖注入","slug":"【SSM框架入门】spring创建bean的三种方式和依赖注入","date":"2020-09-23T09:54:38.617Z","updated":"2020-09-23T10:06:49.686Z","comments":true,"path":"2020/09/23/【SSM框架入门】spring创建bean的三种方式和依赖注入/","link":"","permalink":"http://yoursite.com/2020/09/23/%E3%80%90SSM%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E3%80%91spring%E5%88%9B%E5%BB%BAbean%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%92%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/","excerpt":"","text":"1. spring创建bean的三种方式1.1 使用默认构造函数创建。在spring的配置文件中使用bean标签，配以id和class属性之后,且没有其他属性和标签时采用的就是默认构造函数创建bean对象，此时如果类中没有默认构造函数，则对象无法创建 beans.xml12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\"&gt; &lt;bean id=\"accountService\" class=\"com.spring.service.impl.AccountServiceImpl\"&gt;&lt;/bean&gt;&lt;/beans&gt; service实现类123456789101112131415package com.spring.service.impl;import com.spring.service.IAccountService;public class AccountServiceImpl implements IAccountService &#123; public AccountServiceImpl()&#123; System.out.println(\"对象创建了\"); &#125; public void saveAccount()&#123; System.out.println(\"service中的saveAccount方法执行了\"); &#125;&#125; 使用spring的IOC获取实现类对象1234567891011121314151617181920package com.spring.ui;import com.spring.service.IAccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Client &#123; /** * 获取spring的Ioc核心容器，并创建id获取对象 * @param args */ public static void main(String[] args) &#123; //1.获取核心容器对象 ApplicationContext ac = new ClassPathXmlApplicationContext(\"spring-bean.xml\"); //2.根据id获取Bean对象 IAccountService as = (IAccountService) ac.getBean(\"accountService\"); System.out.println(as); &#125;&#125; 输出结果如果此时将实现类中的默认构造函数覆盖成有参构造函数，程序运行后会报错，提示没有默认构造函数 1.2 使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器）创建一个工厂类，通过工厂类中的getAccountService方法返回一个AccountServiceImpl对象 工厂类1234567891011121314package com.spring.factory;import com.spring.service.IAccountService;import com.spring.service.impl.AccountServiceImpl;/** * 模拟一个工厂类（该类可能是存在于jar包中，我们无法通过修改源码的方式来提供默认构造函数） */public class InstanceFactory &#123; public IAccountService getAccountService()&#123; return new AccountServiceImpl(); &#125;&#125; beans.xml第一个bean配置的是工厂类的id和全限定类名，第二个bean配置的是使用spring的IOC获取对象的id，“factory-bean”属性配置的是上一个bean中工厂类的id，“factory-method”配置的是工厂类中获取对象的方法名 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\"&gt; &lt;!-- 使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器）--&gt; &lt;bean id=\"instanceFactory\" class=\"com.spring.factory.InstanceFactory\"&gt;&lt;/bean&gt; &lt;bean id=\"accountService\" factory-bean=\"instanceFactory\" factory-method=\"getAccountService\"&gt; &lt;/bean&gt;&lt;/beans&gt; 1.3 使用工厂中的静态方法创建对象（使用某个类中的静态方法创建对象，并存入spring容器）创建一个工厂类，通过工厂类中的静态getAccountService方法返回一个AccountServiceImpl对象 工厂类1234567891011121314package com.spring.factory;import com.spring.service.IAccountService;import com.spring.service.impl.AccountServiceImpl;/** * 模拟一个工厂类（该类可能是存在于jar包中，我们无法通过修改源码的方式来提供默认构造函数） */public class staticFactory &#123; public static IAccountService getAccountService()&#123; return new AccountServiceImpl(); &#125;&#125; beans.xml123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\"&gt; &lt;!-- 使用工厂中的静态方法创建对象（使用某个类中的静态方法创建对象，并存入spring容器） --&gt; &lt;bean id=\"accountService\" class=\"com.spring.factory.staticFactory\" factory-method=\"getAccountService\"&gt;&lt;/bean&gt;&lt;/beans&gt; bean的作用范围调整bean标签的scope属性用于指定bean的作用范围，常用的是单例和多例 singleton：单例（默认值）prototype：多例request：作用于web应用的请求范围session：作用于web应用的会话范围global-session：作用于集群环境的会话范围（全局会话范围），当不是集群环境时，它就是session 当使用singleton属性时，对象只被创建了一次 1&lt;bean id=\"accountService\" class=\"com.spring.service.impl.AccountServiceImpl\" scope=\"singleton\"&gt;&lt;/bean&gt; 当使用prototype属性时，对象只被创建了两次次 1&lt;bean id=\"accountService\" class=\"com.spring.service.impl.AccountServiceImpl\" scope=\"prototype\"&gt;&lt;/bean&gt; bean对象的生命周期单例对象出生：当容器创建时对象出生活着：只要容器还在,对象一直活着死亡：容器销,对象消亡总结：单例对象的生命周期和容器相同 多例对象出生：当我们使用对象时spring框架为我们创建活着：对象只要是在使用过程中就一直活着死亡：当对象长时间不用，且没有别的对象引用时，由]ava的垃圾回收器回收 2. spring的依赖注入spring的IOC的作用是降低程序间的耦合（依赖关系），依赖关系的管理都交给spring来维护， 在当前类需要用到其他类的对象，由spring为我们提供，我们只需要在配置文件中说明。依赖关系的维护就称之为依赖注入（ Dependency Injection ） 依赖注入能注入的数据有三类：基本类型和String、其他bean类型（在配置文件中或者注解配置过的bean）、 复杂类型/集合类型 注入的方式有三种：使用构造函数提供、使用set方法提供、使用注解提供 2.1 构造函数注入构造函数注入是在bean标签的内部使用的“constructor-arg”标签 标签中的属性：type：用于指定要注入的数据的数据类型，改数据类型也是构造函数中某个或某些参数的类型index：用于指定要注入的数据给构造函数中指定索引位置的参数赋值，索引的位置是从0开始name：用于指定给构造函数中指定名称的参数赋值（常用）（以上三个属性用于指定给构造函数中哪个参数赋值）value：用于提供基本类型和String类型的数据ref：用于指定其他的bean类数据，它指的就是在spring的Ioc核心容器中出现过的bean对象 实例创建一个实现类，在类中定义三个变量，分别为基本类型Interger的age、String类型的name和java.util.Date类型的birthday。覆写带这三个参数的构造方法 实现类12345678910111213141516171819202122232425package com.spring.service.impl;import com.spring.service.IAccountService;import java.util.Date;public class AccountServiceImpl implements IAccountService &#123; //如果是经常变化的数据，并不适应于注入的方式 private String name; private Integer age; private Date birthday; public AccountServiceImpl(String name,Integer age,Date birthday)&#123; this.name = name; this.age = age; this.birthday = birthday; &#125; public void saveAccount()&#123; System.out.println(\"service中的saveAccount方法执行了---姓名：\"+name+\",年龄：\"+age+\",生日：\"+birthday); &#125;&#125; spring配置文件其中birthday的类型是java.util.Date，所有不能直接使用value，而要使用ref，同时需要写一个java.util.Date的Bean通过spring获取Date对象 12345678&lt;!-- 构造函数注入 --&gt;&lt;bean id=\"accountService\" class=\"com.spring.service.impl.AccountServiceImpl\"&gt; &lt;constructor-arg name=\"name\" value=\"张三\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"age\" value=\"18\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"birthday\" ref=\"now\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!-- 配置一个日期对象 --&gt;&lt;bean id=\"now\" class=\"java.util.Date\"&gt;&lt;/bean&gt; 运行结果优势：在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功。弊端：改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供。 2.2 使用set方法注入（常用）set方法注入是在bean标签的内部使用的“property”标签 标签的属性：name：用于指定注入时所调用的set方法名称value：用于提供基本类型和String类型的数据ref：用于指定其他的bean类型数据。它指的就是在spring的Ioc核心容器中出现过的bean对象 实例创建一个实现类，在类中定义三个变量，分别为基本类型Interger的age、String类型的name和java.util.Date类型的birthday，并添加相应的set方法 实现类12345678910111213141516171819202122232425262728293031package com.spring.service.impl;import com.spring.service.IAccountService;import java.util.Date;public class AccountServiceImpl2 implements IAccountService &#123; //如果是经常变化的数据，并不适应于注入的方式 private String name; private Integer age; private Date birthday; public void setName(String name) &#123; this.name = name; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public void saveAccount()&#123; System.out.println(\"service中的saveAccount方法执行了---姓名：\"+name+\",年龄：\"+age+\",生日：\"+birthday); &#125;&#125; spring配置文件其中birthday的类型是java.util.Date，所有不能直接使用value，而要使用ref，同时需要写一个java.util.Date的Bean通过spring获取Date对象 1234567&lt;!-- set方法注入 --&gt;&lt;bean id=\"accountService2\" class=\"com.spring.service.impl.AccountServiceImpl2\"&gt; &lt;property name=\"name\" value=\"张三\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"18\"&gt;&lt;/property&gt; &lt;property name=\"birthday\" ref=\"now\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;bean id=\"now\" class=\"java.util.Date\"&gt;&lt;/bean&gt; 运行结果优势：创建对象时没有明确的限制，可以直接使用默认构造函数弊端：如果有某个成员必须有值，则获取对象时有可能set方法没有执行 2.3 使用set方法注入复杂类型实例创建一个实现类，在类中定义String类型的数组、List、Set、Map和Properties对象，并添加相应的set方法 实现类123456789101112131415161718192021222324252627282930313233343536373839404142package com.spring.service.impl;import com.spring.service.IAccountService;import java.util.*;public class AccountServiceImpl3 implements IAccountService &#123; private String[] myStrs; private List&lt;String&gt; myList; private Set&lt;String&gt; mySet; private Map&lt;String,String&gt; myMap; private Properties myProps; public void setMyStrs(String[] myStrs) &#123; this.myStrs = myStrs; &#125; public void setMyList(List&lt;String&gt; myList) &#123; this.myList = myList; &#125; public void setMySet(Set&lt;String&gt; mySet) &#123; this.mySet = mySet; &#125; public void setMyMap(Map&lt;String, String&gt; myMap) &#123; this.myMap = myMap; &#125; public void setMyProps(Properties myProps) &#123; this.myProps = myProps; &#125; public void saveAccount() &#123; System.out.println(Arrays.toString(myStrs)); System.out.println(myList); System.out.println(mySet); System.out.println(myMap); System.out.println(myProps); &#125;&#125; spring配置文件1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- set方法注入复杂类型 --&gt;&lt;bean id=\"accountService3\" class=\"com.spring.service.impl.AccountServiceImpl3\"&gt; &lt;property name=\"myStrs\"&gt; &lt;array&gt; &lt;value&gt;Array1&lt;/value&gt; &lt;value&gt;Array2&lt;/value&gt; &lt;value&gt;Array3&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=\"myList\"&gt; &lt;list&gt; &lt;value&gt;List1&lt;/value&gt; &lt;value&gt;List2&lt;/value&gt; &lt;value&gt;List3&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"mySet\"&gt; &lt;set&gt; &lt;value&gt;Set1&lt;/value&gt; &lt;value&gt;Set2&lt;/value&gt; &lt;value&gt;Set3&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=\"myMap\"&gt; &lt;map&gt; &lt;entry key=\"MapA\" value=\"Map1\"&gt;&lt;/entry&gt; &lt;entry key=\"MapB\"&gt; &lt;value&gt;Map2&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=\"myProps\"&gt; &lt;props&gt; &lt;prop key=\"PropsA\"&gt;Props1&lt;/prop&gt; &lt;prop key=\"PropsB\"&gt;Props2&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; 运行结果用于给List结构集合注入的标签：list、array、set用于给Map结构集合注入的标签：map、props其中结构相同，标签可以互换。例如把String数组和list的标签互换输出结果仍然和没有换标签是一样 2.4 依赖注入待续","categories":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/categories/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/tags/SSM/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"【SSM框架入门】spring基于XML的IOC环境搭建","slug":"【SSM框架入门】spring基于XML的IOC环境搭建","date":"2020-09-23T09:54:28.405Z","updated":"2020-09-23T10:07:11.150Z","comments":true,"path":"2020/09/23/【SSM框架入门】spring基于XML的IOC环境搭建/","link":"","permalink":"http://yoursite.com/2020/09/23/%E3%80%90SSM%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E3%80%91spring%E5%9F%BA%E4%BA%8EXML%E7%9A%84IOC%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"IoC全称为Inversion of Control，即 “控制反转”。在Spring框架里，实现IOC，是通过IOC容器实现的，由IOC容器负责创建和获取依赖对象，对象只是被动地接受依赖对象。 1. 创建一个maven工程 2. 在pom.xml中导入spring依赖1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.spring&lt;/groupId&gt; &lt;artifactId&gt;spring&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3. 创建dao层接口和实现类在com.spring.dao中创建一个IAccountDao接口，在com.spring.dao.impl中创建IAccountDao接口的实现类AccountDaoImpl 12345package com.spring.dao;public interface IAccountDao &#123; void saveAccount();&#125; 123456789package com.spring.dao.impl;import com.spring.dao.IAccountDao;public class AccountDaoImpl implements IAccountDao &#123; public void saveAccount() &#123; System.out.println(\"保存成功\"); &#125;&#125; 4. 创建Service层接口和实现类在com.spring.service中创建一个IAccountService接口，在com.spring.service.impl中创建IAccountService接口的实现类AccountServiceImpl 12345package com.spring.service;public interface IAccountService &#123; void saveAccount();&#125; 123456789101112131415package com.spring.service.impl;import com.spring.dao.IAccountDao;import com.spring.dao.impl.AccountDaoImpl;import com.spring.service.IAccountService;public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao = new AccountDaoImpl(); public void saveAccount()&#123; accountDao.saveAccount(); &#125;&#125; 5. 在resouces目录下创建spring配置文件导入beans约束后，在beans标签中添加两个bean标签，id是获取时的唯一标志，class是反射要创建对象的全限定类名。这里我们需要spring帮我们创建AccountServiceImpl和AccountDaoImpl两个类 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\"&gt; &lt;!-- 把对象的创建交给spring来管理 --&gt; &lt;bean id=\"accountService\" class=\"com.spring.service.impl.AccountServiceImpl\"&gt;&lt;/bean&gt; &lt;bean id=\"accountDao\" class=\"com.spring.dao.impl.AccountDaoImpl\"&gt;&lt;/bean&gt;&lt;/beans&gt; 6. 创建Client类获取spring的Ioc核心容器，并创建id获取对象获取对象有两种写法，Client类中as拿到的是Object类型的对象，要自己强转；adao中除了id，还传入了IAccountDao的字节码，通过字节码自动强转 ApplicationContext的三个常用实现类：ClassPathXmlApplicationContext：它可以加载类路径下的配置文件，要求配置文件必须在类路径下。不在的话加载不了。FileSystemXmlApplicationContext：它可以加载磁盘任意路径下的配置文件（必须有访问权限）AnnotationConfigApplicationContext：用于读取注解创建容器 1234567891011121314151617181920212223package com.spring.ui;import com.spring.dao.IAccountDao;import com.spring.service.IAccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Client &#123; /** * 获取spring的Ioc核心容器，并创建id获取对象 * @param args */ public static void main(String[] args) &#123; //1.获取核心容器对象 ApplicationContext ac = new ClassPathXmlApplicationContext(\"spring-bean.xml\"); //2.根据id获取Bean对象 IAccountService as = (IAccountService) ac.getBean(\"accountService\"); IAccountDao adao = ac.getBean(\"accountDao\",IAccountDao.class); System.out.println(as); System.out.println(adao); &#125;&#125; 输出结果 工程结构","categories":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/categories/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/tags/SSM/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Java创建对象的几种方式","slug":"Java创建对象的几种方式","date":"2020-09-17T01:58:44.344Z","updated":"2020-10-01T12:23:42.892Z","comments":true,"path":"2020/09/17/Java创建对象的几种方式/","link":"","permalink":"http://yoursite.com/2020/09/17/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"1、 用new语句创建对象，这是最常见的创建对象的方法。2、 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。3、 调用对象的clone()方法。4、运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。1和2都会明确的显式的调用构造函数 ；3是在内存上对已有对象的影印，所以不会调用构造函数 ；4是从文件中还原类的对象，也不会调用构造函数。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"【SSM框架入门】mybatis的连接池","slug":"【SSM框架入门】mybatis的连接池","date":"2020-09-16T08:36:09.277Z","updated":"2020-09-17T02:01:36.250Z","comments":true,"path":"2020/09/16/【SSM框架入门】mybatis的连接池/","link":"","permalink":"http://yoursite.com/2020/09/16/%E3%80%90SSM%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E3%80%91mybatis%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%B1%A0/","excerpt":"","text":"mybatis连接池提供了3种方式的配置 配置的位置主配置文件中的datasource标签，type属性就是表示采用何种连接池方式 type属性的取值POOLED采用传统的javax.sql.DataSource规范中的连接池, mybatis中有针对规范的实现UNPOOLED采用传统的获取连接的方式，虽然也实现javax.sql.DataSource接口，但是并没有使用池的思想JNDI采用服务器提供的JNDI技术实现，来获取 DataSource对象，不间的服务器所能拿到 DataSource是不一样的（如果不是web或者maven的war工程，是不能使用的）","categories":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/categories/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/tags/SSM/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"【SSM框架入门】mybatis的typeAlias标签和package标签","slug":"【SSM框架入门】mybatis的typeAlias标签和package标签","date":"2020-09-16T08:36:04.226Z","updated":"2020-09-17T02:01:26.425Z","comments":true,"path":"2020/09/16/【SSM框架入门】mybatis的typeAlias标签和package标签/","link":"","permalink":"http://yoursite.com/2020/09/16/%E3%80%90SSM%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E3%80%91mybatis%E7%9A%84typeAlias%E6%A0%87%E7%AD%BE%E5%92%8Cpackage%E6%A0%87%E7%AD%BE/","excerpt":"","text":"1. typeAlias标签在mybatis中可以使用typeAliases标签给mapper文件的全限定类名配置别名，它只能配置domain中类的别名。配置后在mapper文件中的全限定类名就可以替换成别名 1.1 在主配置文件的typeAliases标签中添加typeAlias标签其中type属性指定的是实体类全限定类名。alias属性指定别名,当指定了别名就再区分大小写 1.2 修改mapper文件中参数的类名 2. package标签2.1 typeAliases标签中的package标签package标签用于指定要配置别名的包，当指定之后，该包下的实体类都会注册别名，并且类名就是别名，不再区分大小写 mybatis中标签必须按照这个顺序写，不然会报错(properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,plugins?,environments?,databaseIdProvider?,mappers?) 2.2 mappers标签中的package标签mappers标签中的package标签是用于指定dao接口所在的包,当指定了之后就不需要再写mapper以及resource或者class了","categories":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/categories/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/tags/SSM/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"【SSM框架入门】mybatis的properties配置","slug":"【SSM框架入门】mybatis的properties配置","date":"2020-09-16T08:35:57.998Z","updated":"2020-09-17T02:01:17.699Z","comments":true,"path":"2020/09/16/【SSM框架入门】mybatis的properties配置/","link":"","permalink":"http://yoursite.com/2020/09/16/%E3%80%90SSM%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E3%80%91mybatis%E7%9A%84properties%E9%85%8D%E7%BD%AE/","excerpt":"","text":"在【SSM框架入门】mybatis的增删改查操作中连接池的配置使用的是mybatis的dataSource标签其实mybatis的主配置文件中还有一个properties标签，可以在标签内配置连接数据库的信息，也可以通过属性引用外部配置文件信息 1. property子元素在properties属性中增加子属性property，从而设置一些配置的key-value 2. properties文件直接使用properties引入外部配置文件，相当于将子属性抽取成一个独立的外部文件引入。其中有两个属性，分别resource和url属性 2.1 resource属性用于指定配置文件的位置，是按照类路径的写法来写，并且必须存在于类路径下这里在工程的resources目录下新建一个jdbcConfig.properties文件，然后在mybatis的主配置文件下使用properties标签的resource属性引入jdbcConfig.properties文件mybatis主配置文件中的property中的value与jdbcConfig.properties文件中的key一一对应 2.2 url属性：按照Url的写法来写地址url可以引入网络路径或者本地磁盘路径下的资源 12&lt;properties url=\"xxx\"&gt;&lt;/properties&gt; URL: Uniform Resource Locator 统一资源定位符，它是可以唯一标识一个资源的位置它的写法：http://localhost:8080/mybatisserver/demoServlet其中http是协议，localhost是主机，8080是 端口，mybatisserver/demoServlet是URI","categories":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/categories/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/tags/SSM/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"【SSM框架入门】mybatis中实体类属性名和字段名不一致的解决方法","slug":"【SSM框架入门】mybatis中实体类属性名和字段名不一致的解决方法","date":"2020-09-16T08:35:47.045Z","updated":"2020-09-17T02:02:03.974Z","comments":true,"path":"2020/09/16/【SSM框架入门】mybatis中实体类属性名和字段名不一致的解决方法/","link":"","permalink":"http://yoursite.com/2020/09/16/%E3%80%90SSM%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E3%80%91mybatis%E4%B8%AD%E5%AE%9E%E4%BD%93%E7%B1%BB%E5%B1%9E%E6%80%A7%E5%90%8D%E5%92%8C%E5%AD%97%E6%AE%B5%E5%90%8D%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","excerpt":"","text":"在前面【SSM框架入门】mybatis的增删改查操作中，mysql中user表字段名和实体类中的属性名一一对应，所有增删改查操作都能正常执行。但是当实体类中属性名与mysql表中字段名不对应时，mybatis无法映射。此时把mapper文件的值修改为实体类的属性名，增删改是可以正常执行的。但是进行查询操作时输出结果中除了userName，其余属性全为null这是因为实体类中的属性名和user表字段名不一样，mybatis无法完成映射（userName不为空是因为mysql在window下不区分大小写）。 此时可以通过起别名或者配置查询结果的列名和实体类属性名的对应关系解决映射问题 1. 起别名输出结果 2. 配置resultMap标签12345678910&lt;!-- 配置 查询结果的列名和实体类的属性名的对应关系 --&gt; &lt;resultMap id=\"userMap\" type=\"com.ssm.domain.User\"&gt; &lt;!-- 主键字段的对应 --&gt; &lt;id property=\"userId\" column=\"id\"&gt;&lt;/id&gt; &lt;!-- 非主键字段的对应 --&gt; &lt;result property=\"userName\" column=\"username\"&gt;&lt;/result&gt; &lt;result property=\"userBirthday\" column=\"birthday\"&gt;&lt;/result&gt; &lt;result property=\"userSex\" column=\"sex\"&gt;&lt;/result&gt; &lt;result property=\"userAddress\" column=\"address\"&gt;&lt;/result&gt; &lt;/resultMap&gt; 并把select标签中的resultType属性改为resultMap输出结果","categories":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/categories/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/tags/SSM/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"【SSM框架入门】mybatis的增删改查操作","slug":"【SSM框架入门】mybatis的增删改查操作","date":"2020-09-16T08:35:37.980Z","updated":"2020-09-17T02:01:45.661Z","comments":true,"path":"2020/09/16/【SSM框架入门】mybatis的增删改查操作/","link":"","permalink":"http://yoursite.com/2020/09/16/%E3%80%90SSM%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E3%80%91mybatis%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E6%93%8D%E4%BD%9C/","excerpt":"","text":"1. 新建数据库和表新建一个名为ssm的数据库，并创建一个user表，给user表插入几条数据 2. 新建一个maven工程 3. pom.xml导入坐标这里只需要导入mybatis和连接mysql的包，另外可以导入log4j和junit的包 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.ssm&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar &lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 4. 创建实体类和DAO接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.ssm.domain;import java.io.Serializable;import java.util.Date;public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"id=\" + id + \", username='\" + username + '\\'' + \", birthday=\" + birthday + \", sex='\" + sex + '\\'' + \", address='\" + address + '\\'' + '&#125;'; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536package com.ssm.dao;import com.ssm.domain.User;import org.apache.ibatis.annotations.Select;import java.util.List;/** * 用户的持久层接口 */public interface IUserDao &#123; /** * 查询所有 * @return */// @Select(\"select * from user\") List&lt;User&gt; findAll(); /** * 保存用户 * @param user */ void saveUser(User user); /** * 更新用户 * @param user */ void updateUser(User user); /** * 更加Id删除用户 * @param userId */ void deleteUser(Integer userId);&#125; 5. 创建Mybatis的主配置文件——SqlMapConfig.xml123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;!-- mybatis的主配置文件 --&gt;&lt;configuration&gt; &lt;!-- 配置环境 --&gt; &lt;environments default=\"mysql\"&gt; &lt;!-- 配置mysql的环境 --&gt; &lt;environment id=\"mysql\"&gt; &lt;!-- 配置事务的类型 --&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;!-- 配置数据源（连接池） --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC\" /&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"123456\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 --&gt; &lt;mappers&gt; &lt;mapper resource=\"com/ssm/dao/IUserDao.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 6. 创建映射配置文件——IUserDao.xml在配置文件中添加增删改查的sql语句 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.ssm.dao.IUserDao\"&gt; &lt;!-- 查询所有 --&gt; &lt;select id=\"findAll\" resultType=\"com.ssm.domain.User\"&gt; select * from user &lt;/select&gt; &lt;!-- 保存用户 --&gt; &lt;insert id=\"saveUser\" parameterType=\"com.ssm.domain.User\"&gt; insert into user(username,address,sex,birthday) values(#&#123;username&#125;,#&#123;address&#125;,#&#123;sex&#125;,#&#123;birthday&#125;) &lt;/insert&gt; &lt;!-- 更新用户 --&gt; &lt;update id=\"updateUser\" parameterType=\"com.ssm.domain.User\"&gt; update user set username = #&#123;username&#125;,address = #&#123;address&#125;,birthday = #&#123;birthday&#125;,sex = #&#123;sex&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;!-- 删除用户 --&gt; &lt;delete id=\"deleteUser\" parameterType=\"java.lang.Integer\"&gt; delete from user where id = #&#123;uid&#125; &lt;/delete&gt;&lt;/mapper&gt; 7. 编写测试类因为增删改查的测试方法都要用到SqlSessionFactoryBuilder创建SqlSessionFactory工厂等等，所以把方法中相同的部分提取出来另写一个方法init()，包括方法最后的关闭资源操作也独立出来一个方法destroy() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.ssm.test;import com.ssm.dao.IUserDao;import com.ssm.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.io.IOException;import java.io.InputStream;import java.util.Date;import java.util.List;public class MybatisTest &#123; private InputStream in; private SqlSession sqlSession; private IUserDao userDao; @Before public void init()throws Exception&#123; //1.读取配置文件 in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); //2.创建SqlSessionFactory工厂 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(in); //3.使用工厂生产SqlSession对象 sqlSession = factory.openSession(); //4.使用SqlSession创建Dao接口的代理对象 userDao = sqlSession.getMapper(IUserDao.class); &#125; @After public void destroy() throws IOException &#123; //提交事务 sqlSession.commit(); //6.释放资源 sqlSession.close(); in.close(); &#125; /** * 测试查询所有操作 */ @Test public void testFindAll()throws Exception&#123; //5.使用代理对象执行方法 List&lt;User&gt; users = userDao.findAll(); for (User user : users) &#123; System.out.println(user); &#125; &#125; /** * 测试保存操作 */ @Test public void testSave() throws IOException &#123; User user = new User(); user.setUsername(\"测试\"); user.setAddress(\"成都市\"); user.setBirthday(new Date()); user.setSex(\"男\"); //5.执行保存方法 userDao.saveUser(user); &#125; /** * 测试更新操作 */ @Test public void testUpdateUser() throws IOException &#123; User user = new User(); user.setId(1); user.setUsername(\"张四\"); user.setAddress(\"天津\"); user.setBirthday(new Date()); user.setSex(\"女\"); //5.执行保存方法 userDao.updateUser(user); &#125; /** * 测试删除操作 */ @Test public void testDeleteUser() throws IOException &#123; //5.执行删除方法 userDao.deleteUser(7); &#125;&#125; 8. Maven工程结构 9. 运行结果这里以添加用户操作为实例①在没有手动进行事务提交之前，程序虽然运行成功了，但是数据库中并没有插入数据。输出结果中显示“Setting autocommit to false”，因为mybatis的自动提交是默认关闭的，所以执行完插入操作后进行了事务回滚。这时候数据库的user表中生成了key值但是并没有数据写入，就浪费了一个key值。当重新插入数据并提交事务后，主键的自增值不是+1，而是在上一条数据的基础上+2②提交事务可以通过在添加操作后加入“sqlSession.commit();”或者在使用工厂生产SqlSession对象时，在openSession()方法中传入true手动进行事务提交后，重新执行代码输出结果显示“Committing JDBC Connection”，查看user表，数据以及成功插入","categories":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/categories/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/tags/SSM/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"【SSM框架入门】mybatis编写dao实现类","slug":"【SSM框架入门】mybatis编写dao实现类","date":"2020-09-16T08:35:25.880Z","updated":"2020-09-17T02:01:08.066Z","comments":true,"path":"2020/09/16/【SSM框架入门】mybatis编写dao实现类/","link":"","permalink":"http://yoursite.com/2020/09/16/%E3%80%90SSM%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E3%80%91mybatis%E7%BC%96%E5%86%99dao%E5%AE%9E%E7%8E%B0%E7%B1%BB/","excerpt":"","text":"mybatis编写dao实现类的过程较繁琐，在实际开发中没有意义。此文章仅作为mybatis知识的扩展，并以此了解mybatis通过代理dao定位sql语句的过程，即通过mapper配置文件中namespace和id属性定位sql语句 工程结构目录 在【SSM框架入门】mybatis环境搭建的基础上，新建一个IUserDao的实现类UserDaoImpl 12345678910111213141516171819202122232425262728package com.ssm.dao.impl;import com.ssm.dao.IUserDao;import com.ssm.domain.User;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import java.util.List;public class UserDaoImpl implements IUserDao &#123; private SqlSessionFactory factory; public UserDaoImpl(SqlSessionFactory factory)&#123; this.factory = factory; &#125; @Override public List&lt;User&gt; findAll() &#123; //1.使用工厂创建SqlSession对象 SqlSession session = factory.openSession(); //2.使用session执行查询所有方法 List&lt;User&gt; users = session.selectList(\"com.ssm.dao.IUserDao.findAll\"); session.close(); //3.返回查询结果 return users; &#125;&#125; 修改Test中的MybatisTest类 12345678910111213141516171819202122232425262728293031package com.ssm.test;import com.ssm.dao.IUserDao;import com.ssm.dao.impl.UserDaoImpl;import com.ssm.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.InputStream;import java.util.List;public class MybatisTest &#123; public static void main(String[] args)throws Exception &#123; //1.读取配置文件 InputStream in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); //2.创建SqlSessionFactory工厂 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(in); //3.使用工厂创建dao的对象 IUserDao userDao = new UserDaoImpl(factory); //4.使用代理对象执行方法 List&lt;User&gt; users = userDao.findAll(); for (User user : users) &#123; System.out.println(user); &#125; //5.释放资源 in.close(); &#125;&#125; 运行结果","categories":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/categories/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/tags/SSM/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"【SSM框架入门】mybatis环境搭建与入门案例","slug":"【SSM框架入门】mybatis环境搭建与入门案例","date":"2020-09-16T08:35:14.352Z","updated":"2020-09-17T02:01:53.963Z","comments":true,"path":"2020/09/16/【SSM框架入门】mybatis环境搭建与入门案例/","link":"","permalink":"http://yoursite.com/2020/09/16/%E3%80%90SSM%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E3%80%91mybatis%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%8E%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B/","excerpt":"","text":"1. Maven工程结构 2. mybatis环境搭建2.1 新建数据库和表 2.2 新建一个maven工程 2.3 pom.xml导入坐标1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.ssm&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar &lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2.4 创建实体类和DAO接口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.ssm.domain;import java.io.Serializable;import java.util.Date;public class User implements Serializable &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"id=\" + id + \", username='\" + username + '\\'' + \", birthday=\" + birthday + \", sex='\" + sex + '\\'' + \", address='\" + address + '\\'' + '&#125;'; &#125;&#125; 12345678910111213141516package com.ssm.dao;import com.ssm.domain.User;import java.util.List;/** * 用户的持久层接口 */public interface IUserDao &#123; /** * 查询所有 * @return */ List&lt;User&gt; findAll();&#125; 2.5 创建Mybatis的主配置文件——SqlMapConfig.xml123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;!-- mybatis的主配置文件 --&gt;&lt;configuration&gt; &lt;!-- 配置环境 --&gt; &lt;environments default=\"mysql\"&gt; &lt;!-- 配置mysql的环境 --&gt; &lt;environment id=\"mysql\"&gt; &lt;!-- 配置事务的类型 --&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;!-- 配置数据源（连接池） --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt; &lt;property name=\"driver\" value=\"com.mysql.cj.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/ssm?serverTimezone=UTC\" /&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"123456\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件 --&gt; &lt;mappers&gt; &lt;mapper resource=\"com/ssm/dao/IUserDao.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 2.6 创建映射配置文件——IUserDao.xml12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.ssm.dao.IUserDao\"&gt; &lt;!-- 配置查询所有 --&gt; &lt;select id=\"findAll\" resultType=\"com.ssm.domain.User\"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 环境搭建的注意事项:①在Mybatis中持久层的操作接口名称和映射文件也叫做: Mapper所以: IUserdao和IUserMapper是一样的②在idea中创建目录的时候,它和包是不一样的包在创建时:com. i theima.dao它是三级结构目录在创建时:com. i theima.dao是一级目录③myatis的映射配置文件位置必须和dao接口的包结构相同④映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名⑤映射配置文件的操作配置(select),id属性的取值必须是dao接口的方法名 3. mybatis入门案例3.1 在Test中创建MybatisTest类 123456789101112131415161718192021222324252627282930313233package com.ssm.test;import com.ssm.dao.IUserDao;import com.ssm.domain.User;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.InputStream;import java.util.List;public class MybatisTest &#123; public static void main(String[] args)throws Exception &#123; //1.读取配置文件 InputStream in = Resources.getResourceAsStream(\"SqlMapConfig.xml\"); //2.创建SqlSessionFactory工厂 SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); SqlSessionFactory factory = builder.build(in); //3.使用工厂生产SqlSession对象 SqlSession session = factory.openSession(); //4.使用SqlSession创建Dao接口的代理对象 IUserDao userDao = session.getMapper(IUserDao.class); //5.使用代理对象执行方法 List&lt;User&gt; users = userDao.findAll(); for (User user : users) &#123; System.out.println(user); &#125; //6.释放资源 session.close(); in.close(); &#125;&#125; 3.2 执行结果","categories":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/categories/SSM/"}],"tags":[{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/tags/SSM/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"【蓝桥杯】基础练习试题","slug":"【蓝桥杯】基础练习试题","date":"2020-08-08T15:02:41.592Z","updated":"2020-08-08T15:04:15.063Z","comments":true,"path":"2020/08/08/【蓝桥杯】基础练习试题/","link":"","permalink":"http://yoursite.com/2020/08/08/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E8%AF%95%E9%A2%98/","excerpt":"","text":"1.闰年判断资源限制时间限制：1.0s 内存限制：256.0MB 问题描述给定一个年份，判断这一年是不是闰年。当以下情况之一满足时，这一年是闰年：1.年份是4的倍数而不是100的倍数；2. 年份是400的倍数。其他的年份都不是闰年。 输入格式输入包含一个整数y，表示当前的年份。 输出格式输出一行，如果给定的年份是闰年，则输出yes，否则输出no。 代码123456789101112import java.util.Scanner;public class Main&#123; public static void main(String arg[])&#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); if((n%4==0&amp;&amp;n%100!=0)||n%400==0) System.out.print(\"yes\"); else System.out.print(\"no\"); &#125;&#125; 2.01字串资源限制时间限制：1.0s 内存限制：256.0MB 问题描述对于长度为5位的一个01串，每一位都可能是0或1，一共有32种可能。它们的前几个是：0000000001000100001100100请按从小到大的顺序输出这32种01串。 输入格式本试题没有输入。 输出格式输出32行，按从小到大的顺序每行一个长度为5的01串。 代码123456789public class Main &#123; public static void main(String args[])&#123; for(int i=0;i&lt;32;i++)&#123; String result = Integer.toBinaryString(i); int n = Integer.parseInt(result); System.out.printf(\"%05d\\n\",n); &#125; &#125;&#125; 3.字母图形资源限制时间限制：1.0s 内存限制：256.0MB 问题描述利用字母可以组成一些美丽的图形，下面给出了一个例子：ABCDEFGBABCDEFCBABCDEDCBABCDEDCBABC这是一个5行7列的图形，请找出这个图形的规律，并输出一个n行m列的图形。 输入格式输入一行，包含两个整数n和m，分别表示你要输出的图形的行数的列数。 输出格式输出n行，每个m个字符，为你的图形。 代码12345678910111213141516import java.util.Scanner;public class Main &#123; public static void main(String args[])&#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); int m = in.nextInt(); for(int i = 0 ; i &lt; n; i++) &#123; for(int j = 0 ; j &lt; m ;j++) &#123; char c = (char)(Math.abs(i - j) + 'A'); System.out.print(c); &#125; System.out.println(); &#125; &#125;&#125; 4.数列特征资源限制时间限制：1.0s 内存限制：256.0MB 问题描述给出n个数，找出这n个数的最大值，最小值，和。 输入格式第一行为整数n，表示数的个数。第二行有n个数，为给定的n个数，每个数的绝对值都小于10000。 输出格式输出三行，每行一个整数。第一行表示这些数中的最大值，第二行表示这些数中的最小值，第三行表示这些数的和。 代码12345678910111213141516171819202122232425import java.util.Scanner;public class Main&#123; public static void main(String arg[])&#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); int[] array = new int[n]; for(int i=0;i&lt;array.length;i++)&#123; array[i] = in.nextInt(); &#125; int max = array[0]; int min = array[0]; int sum = 0; for (int i = 0; i &lt; array.length; i++) &#123; if(max&lt;array[i])&#123; max = array[i]; &#125; if(min&gt;array[i])&#123; min = array[i]; &#125; sum = sum + array[i]; &#125; System.out.printf(\"%d%n%d%n%d%n\",max,min,sum); &#125;&#125; 5.查找整数资源限制时间限制：1.0s 内存限制：256.0MB 问题描述给出一个包含n个整数的数列，问整数a在数列中的第一次出现是第几个。 输入格式第一行包含一个整数n。第二行包含n个非负整数，为给定的数列，数列中的每个数都不大于10000。第三行包含一个整数a，为待查找的数。 输出格式如果a在数列中出现了，输出它第一次出现的位置(位置从1开始编号)，否则输出-1。 代码1234567891011121314151617181920212223import java.util.Scanner;public class Main&#123; public static void main(String args[])&#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); int array[] = new int[n]; for(int i=0;i&lt;array.length;i++)&#123; int m = in.nextInt(); array[i]= m ; &#125; int m = in.nextInt(); for(int i=0;i&lt;n;i++)&#123; if(array[i] == m)&#123; System.out.println(i+1); break; &#125; if(i == n-1)&#123; System.out.println(-1); &#125; &#125; &#125;&#125; 6.杨辉三角形资源限制时间限制：1.0s 内存限制：256.0MB 问题描述杨辉三角形又称Pascal三角形，它的第i+1行是(a+b)^i的展开式的系数。它的一个重要性质是：三角形中的每个数字等于它两肩上的数字相加。下面给出了杨辉三角形的前4行： 1 1 1 1 2 11 3 3 1给出n，输出它的前n行。 输入格式输入包含一个数n。 输出格式输出杨辉三角形的前n行。每一行从这一行的第一个数开始依次输出，中间使用一个空格分隔。请不要在前面输出多余的空格。 代码123456789101112131415161718192021import java.util.Scanner;public class Main &#123; public static void main(String[] args)&#123; Scanner in = new Scanner(System.in); int row = in.nextInt(); int[][] arr = new int[row][]; for(int i = 0;i &lt; row;i++)&#123; arr[i] = new int[i + 1]; for(int j = 0;j &lt;= i;j++)&#123; if(j == 0 || j == i)&#123; arr[i][j] = 1; &#125;else&#123; arr[i][j] = arr[i-1][j] + arr[i-1][j-1]; &#125; System.out.print(arr[i][j] + \" \"); &#125; System.out.println(); &#125; &#125;&#125; 7.特殊的数字资源限制时间限制：1.0s 内存限制：512.0MB 问题描述153是一个非常特殊的数，它等于它的每位数字的立方和，即153=1*11+5\\5*5+3*3*3。编程求所有满足这种条件的三位十进制数。 输出格式按从小到大的顺序输出满足条件的三位十进制数，每个数占一行。 代码123456789101112public class Main&#123; public static void main(String args[])&#123; for(int i = 100;i &lt; 1000;i++)&#123; int a = i/100; int b = i%100/10; int c = i%10; if(a*a*a + b*b*b + c*c*c == i)&#123; System.out.println(i); &#125; &#125; &#125;&#125; 8.回文数资源限制时间限制：1.0s 内存限制：512.0MB 问题描述1221是一个非常特殊的数，它从左边读和从右边读是一样的，编程求所有这样的四位十进制数。 输出格式按从小到大的顺序输出满足条件的四位十进制数。 代码123456789public class Main &#123; public static void main(String[] agrs) &#123; for (int i = 1; i &lt; 10; i++) &#123; for (int j = 0; j &lt; 10; j++) &#123; System.out.println(\"\" + i + j + j + i); &#125; &#125; &#125;&#125; 9.特殊回文数资源限制时间限制：1.0s 内存限制：512.0MB 问题描述123321是一个非常特殊的数，它从左边读和从右边读是一样的。输入一个正整数n， 编程求所有这样的五位和六位十进制数，满足各位数字之和等于n 。 输入格式输入一行，包含一个正整数n。 输出格式按从小到大的顺序输出满足条件的整数，每个整数占一行。 代码1234567891011121314151617181920212223import java.util.Scanner;public class Main &#123; public static void main(String[] agrs) &#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); for(int i = 10000;i &lt; 1000000;i++)&#123; if(i &lt; 100000)&#123; if((i%10 == i/10000) &amp;&amp; (i/10%10 == i/1000%10))&#123; if(i%10 + i/10%10 + i/100%10 + i/10000 + i/1000%10 == n)&#123; System.out.println(i); &#125; &#125; &#125;else&#123; if((i%10 == i/100000) &amp;&amp; (i/10%10 == i/10000%10) &amp;&amp; (i/100%10 == i/1000%10))&#123; if(i%10 + i/10%10 + i/100%10 + i/1000%10 + i/100000 + i/10000%10 == n)&#123; System.out.println(i); &#125; &#125; &#125; &#125; &#125;&#125; 10.十进制转十六进制资源限制时间限制：1.0s 内存限制：512.0MB 问题描述十六进制数是在程序设计时经常要使用到的一种整数的表示方式。它有0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F共16个符号，分别表示十进制数的0至15。十六进制的计数方法是满16进1，所以十进制数16在十六进制中是10，而十进制的17在十六进制中是11，以此类推，十进制的30在十六进制中是1E。给出一个非负整数，将它表示成十六进制的形式。 输入格式输入包含一个非负整数a，表示要转换的数。0&lt;=a&lt;=2147483647 输出格式输出这个整数的16进制表示 代码123456789import java.util.Scanner;public class Main&#123; public static void main(String args[])&#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); System.out.printf(\"%X\", n); &#125;&#125; 11.十六进制转十进制资源限制时间限制：1.0s 内存限制：512.0MB 问题描述从键盘输入一个不超过8位的正的十六进制数字符串，将它转换为正的十进制数后输出。注：十六进制数中的10~15分别用大写的英文字母A、B、C、D、E、F表示。 样例输入FFFF 样例输出65535 代码123456789import java.util.Scanner;public class Main&#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); String string = in.nextLine(); System.out.print(Long.valueOf(string,16)); &#125;&#125; 12.十六进制转八进制资源限制时间限制：1.0s 内存限制：512.0MB 问题描述给定n个十六进制正整数，输出它们对应的八进制数。 输入格式输入的第一行为一个正整数n （1&lt;=n&lt;=10）。接下来n行，每行一个由09、大写字母AF组成的字符串，表示要转换的十六进制正整数，每个十六进制数长度不超过100000。 输出格式输出n行，每行为输入对应的八进制正整数。【注意】输入的十六进制数不会有前导0，比如012A。输出的八进制数也不能有前导0。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122import java.util.Scanner;public class Main&#123; public static void main(String[] args)&#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); char[][] str = new char[n][]; for (int i = 0; i &lt; n; i++) &#123; str[i] = new StringBuilder(in.next()).toString().toCharArray(); &#125; in.close(); for (int i = 0; i &lt; n; i++) &#123; //将十六进制转化为二进制 String strBinary = toBinary(str[i]); int len = strBinary.length(); //二进制转为八进制是以三个二进制数为一位八进制数 if (len % 3 == 1) strBinary = \"00\" + strBinary; if (len % 3 == 2) strBinary = \"0\" + strBinary; //将二进制转为八进制 String strOctal = toOctal(strBinary); System.out.println(strOctal); &#125; &#125; private static String toBinary(char[] str)&#123; StringBuffer str3 = new StringBuffer(); for (int i = 0; i &lt; str.length; i++) &#123; switch (str[i]) &#123; case '0': str3.append(\"0000\"); break; case '1': str3.append(\"0001\"); break; case '2': str3.append(\"0010\"); break; case '3': str3.append(\"0011\"); break; case '4': str3.append(\"0100\"); break; case '5': str3.append(\"0101\"); break; case '6': str3.append(\"0110\"); break; case '7': str3.append(\"0111\"); break; case '8': str3.append(\"1000\"); break; case '9': str3.append(\"1001\"); break; case 'A': str3.append(\"1010\"); break; case 'B': str3.append(\"1011\"); break; case 'C': str3.append(\"1100\"); break; case 'D': str3.append(\"1101\"); break; case 'E': str3.append(\"1110\"); break; case 'F': str3.append(\"1111\"); break; default: break; &#125; &#125; return str3.toString(); &#125; private static String toOctal(String str)&#123; StringBuffer strOctal = new StringBuffer(); int k = 0; //这一步的目的是消除转换为八进制后，第一位可能的0 if(str.substring(0, 3).equals(\"000\")) k=3; for (int i = k; i &lt; str.length()-2; i += 3) &#123; switch (str.substring(i, i + 3)) &#123; case \"000\": strOctal.append(\"0\"); break; case \"001\": strOctal.append(\"1\"); break; case \"010\": strOctal.append(\"2\"); break; case \"011\": strOctal.append(\"3\"); break; case \"100\": strOctal.append(\"4\"); break; case \"101\": strOctal.append(\"5\"); break; case \"110\": strOctal.append(\"6\"); break; case \"111\": strOctal.append(\"7\"); break; default: break; &#125; &#125; return strOctal.toString(); &#125;&#125; 13.数列排序资源限制时间限制：1.0s 内存限制：512.0MB 问题描述给定一个长度为n的数列，将这个数列按从小到大的顺序排列。1&lt;=n&lt;=200 输入格式第一行为一个整数n。第二行包含n个整数，为待排序的数，每个整数的绝对值小于10000。 输出格式输出一行，按从小到大的顺序输出排序后的数列。 代码1234567891011121314151617181920212223242526272829import java.util.Arrays;import java.util.Scanner;public class Main&#123; public static void main(String arg[])&#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); int array[] = new int[n]; for(int i=0;i&lt;n;i++)&#123; array[i] = in.nextInt(); &#125; Arrays.sort(array); // for(int j=0;j&lt;array.length-1;j++)&#123;// for(int k=0;k&lt;array.length-1-j;k++)&#123;// if(array[k]&gt;array[k+1])&#123;// int temp = array[k];// array[k] = array[k+1];// array[k+1] = temp;// &#125;// &#125;// &#125; for(int i:array)&#123; System.out.print(i + \" \"); &#125; &#125;&#125;","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://yoursite.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://yoursite.com/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"蓝桥杯--入门训练试题","slug":"【蓝桥杯】入门训练试题","date":"2020-07-29T03:52:03.821Z","updated":"2020-08-08T15:04:24.997Z","comments":true,"path":"2020/07/29/【蓝桥杯】入门训练试题/","link":"","permalink":"http://yoursite.com/2020/07/29/%E3%80%90%E8%93%9D%E6%A1%A5%E6%9D%AF%E3%80%91%E5%85%A5%E9%97%A8%E8%AE%AD%E7%BB%83%E8%AF%95%E9%A2%98/","excerpt":"","text":"1.A+B问题资源限制时间限制：1.0s 内存限制：256.0MB 问题描述输入A、B，输出A+B。 输入格式输入的第一行包括两个整数，由空格分隔，分别表示A、B。 输出格式输出一行，包括一个整数，表示A+B的值。 代码123456789101112import java.util.*;public class Main&#123; public static void main(String args[]) &#123; Scanner sc = new Scanner(System.in); Integer a = sc.nextInt(); Integer b = sc.nextInt(); System.out.println(a + b); &#125;&#125; 2.序列求和资源限制时间限制：1.0s 内存限制：256.0MB 问题描述求1+2+3+…+n的值。 输入格式输入包括一个整数n。 输出格式输出一行，包括一个整数，表示1+2+3+…+n的值。 代码12345678910111213import java.util.Scanner;public class Main &#123; public static void main(String args[])&#123; Scanner in = new Scanner(System.in); long n = in.nextInt(); if(1&lt;=n&amp;&amp;n&lt;=1000000000)&#123; int a = 1; long s = n*a+(n*(n-1))/2; System.out.println(s); &#125; &#125;&#125; 3.圆的面积资源限制时间限制：1.0s 内存限制：256.0MB 问题描述给定圆的半径r，求圆的面积。 输入格式输入包含一个整数r，表示圆的半径。 输出格式输出一行，包含一个实数，四舍五入保留小数点后7位，表示圆的面积。 说明：在本题中，输入是一个整数，但是输出是一个实数。对于实数输出的问题，请一定看清楚实数输出的要求，比如本题中要求保留小数点后7位，则你的程序必须严格的输出7位小数，输出过多或者过少的小数位数都是不行的，都会被认为错误。实数输出的问题如果没有特别说明，舍入都是按四舍五入进行。 代码1234567891011121314import java.util.Scanner;public class Main &#123; public static void main(String args[])&#123; Scanner in = new Scanner(System.in); int r = in.nextInt(); double PI=3.14159265358979323; if(1&lt;=r&amp;&amp;r&lt;=1000000)&#123; double s = r*r*PI; System.out.println(String.format(\"%.7f\",s)); &#125; in.close(); &#125;&#125; 4.Fibonacci数列资源限制时间限制：1.0s 内存限制：256.0MB 问题描述Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。当n比较大时，Fn也非常大，现在我们想知道，Fn除以10007的余数是多少。 输入格式输入包含一个整数n。 输出格式输出一行，包含一个整数，表示Fn除以10007的余数。 说明在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。 代码123456789101112131415161718192021import java.util.Scanner;public class Main &#123; public static void main(String args[])&#123; Scanner in = new Scanner(System.in); int n = in.nextInt(); int F[] = new int[n]; if(1&lt;=n&amp;&amp;n&lt;=1000000)&#123; if(n==1||n==2)&#123; F[n-1]=1; &#125;else&#123; F[0]=1; F[1]=1; for(int i=2;i&lt;n;i++)&#123; F[i]=(F[i-1]+F[i-2])%10007; &#125; &#125; &#125; System.out.println(F[n-1]); &#125;&#125;","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://yoursite.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://yoursite.com/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Java内存分析之对象实例化操作初步分析","slug":"内存分析-对象实例化操作初步分析","date":"2020-07-27T14:22:15.080Z","updated":"2020-07-27T14:49:30.278Z","comments":true,"path":"2020/07/27/内存分析-对象实例化操作初步分析/","link":"","permalink":"http://yoursite.com/2020/07/27/%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90-%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%93%8D%E4%BD%9C%E5%88%9D%E6%AD%A5%E5%88%86%E6%9E%90/","excerpt":"","text":"对象实例化操作初步分析内存分析——&gt;堆内存：保存的是对象的具体信息，在程序之中堆内存空间的开辟是通过new完成的； ​ 栈内存：保存的是一块堆内存的地址，通过地址找到堆内存，而后找到对象内容； 对象的实例化有两种语法，一种是声明并实例化对象，一种是分步完成。 1.声明并实例化代码示例： 123456789101112131415public class JavaDemo&#123; public static void main(String args[])&#123; Person per = new Person(); per.name = \"张三\"; per.age = 18; per.tell(); &#125;&#125;class Person&#123; String name; int age; public void tell()&#123; System.out.println(\"姓名：\"+ name +\"、年龄：\"+ age); &#125;&#125; 2.先声明后实例化代码示例： 12345678910111213141516public class JavaDemo&#123; public static void main(String args[])&#123; Person per = null; per = new Person(); per.name = \"张三\"; per.age = 18; per.tell(); &#125;&#125;class Person&#123; String name; int age; public void tell()&#123; System.out.println(\"姓名：\"+ name +\"、年龄：\"+ age); &#125;&#125; 所有的对象在调用类中的属性或方法的时候必须要实例化完成后才可以执行。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Hexo博客同时托管到github和coding","slug":"Hexo博客同时托管到github和coding","date":"2020-07-27T03:13:59.052Z","updated":"2020-07-27T03:43:24.147Z","comments":true,"path":"2020/07/27/Hexo博客同时托管到github和coding/","link":"","permalink":"http://yoursite.com/2020/07/27/Hexo%E5%8D%9A%E5%AE%A2%E5%90%8C%E6%97%B6%E6%89%98%E7%AE%A1%E5%88%B0github%E5%92%8Ccoding/","excerpt":"","text":"原因之前把Hexo博客托管到github上，访问速度巨慢，有时候直接访问不了。向百度提交了网站收录，几天都没有动静。百度了一下原因是GitHub封锁了百度spider，所以选择把博客托管到Coding上。 1.创建项目注册一个coding账号，创建一个DevOps项目。 2.配置_config.yml进入项目&gt;代码仓库&gt;仓库设置&gt;设置，复制链接。修改博客根目录的_config.yml，根据hexo官方文档修改成这样 3.配置SSH Key密匙的使用和github一样，详细步骤可以参考《同一台机器配置多个ssh——同时绑定coding和github》把生成的密匙添加到coding上。 添加SSH公匙是在个人账户设置&gt;SSH公匙&gt;新增公匙，不是项目中的部署公匙 验证公匙是否配置成功，在git bash中输入 1ssh -T git@e.coding.net 验证的时候如果有警告输入yes回车就好了（我之前配置过，再次验证没有警告） 4.博客部署到coding1hexo deploy 执行Hexo部署命令，博客就会将Hexo博客部署到GitHub和Coding上了。部署后Coding项目master分支下面就会有代码。 5.开启Coding Page进入项目&gt;持续部署&gt;静态网站&gt;新建保存后就可以看到博客的访问地址了，因为我已经绑定域名了，所有还多了域名地址。 6.绑定域名并开启 HTTPS在静态网站页面右上角点击设置，下滑到底部绑定域名。域名绑定前要先添加域名解析，这里我使用的是腾讯云。在腾讯云中添加一条CNAME记录指向博客的访问地址。把coding的解析线路设为默认，github的解析线路修改为境外。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"Valine评论出现Code 403：访问被API域名白名单拒绝，请检查你的安全域名设置","slug":"Valine评论出现Code 403：访问被API域名白名单拒绝，请检查你的安全域名设置","date":"2020-07-26T14:33:44.784Z","updated":"2020-07-26T14:42:31.607Z","comments":true,"path":"2020/07/26/Valine评论出现Code 403：访问被API域名白名单拒绝，请检查你的安全域名设置/","link":"","permalink":"http://yoursite.com/2020/07/26/Valine%E8%AF%84%E8%AE%BA%E5%87%BA%E7%8E%B0Code%20403%EF%BC%9A%E8%AE%BF%E9%97%AE%E8%A2%ABAPI%E5%9F%9F%E5%90%8D%E7%99%BD%E5%90%8D%E5%8D%95%E6%8B%92%E7%BB%9D%EF%BC%8C%E8%AF%B7%E6%A3%80%E6%9F%A5%E4%BD%A0%E7%9A%84%E5%AE%89%E5%85%A8%E5%9F%9F%E5%90%8D%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"问题之前hexo博客部署在GitHub，访问速度巨慢。今天把hexo博客部署到coding，换了个域名，博客valine评论出现了403错误。 解决方法在leancloud的评论应用&gt;设置&gt;安全中心&gt;Web安全域名中修改新的域名","categories":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Valine","slug":"Valine","permalink":"http://yoursite.com/tags/Valine/"}]},{"title":"修改系统hosts文件解决GitHub访问速度慢","slug":"修改系统hosts文件解决GitHub访问速度慢","date":"2020-07-23T13:37:23.664Z","updated":"2020-07-26T14:41:16.215Z","comments":true,"path":"2020/07/23/修改系统hosts文件解决GitHub访问速度慢/","link":"","permalink":"http://yoursite.com/2020/07/23/%E4%BF%AE%E6%94%B9%E7%B3%BB%E7%BB%9Fhosts%E6%96%87%E4%BB%B6%E8%A7%A3%E5%86%B3GitHub%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6%E6%85%A2/","excerpt":"","text":"一、原因分析GitHub的CDN域名遭到DNS污染，导致无法连接使用 GitHub 的加速分发服务器，才使得国内访问速度很慢。 二、解决方法通过修改本地 hosts 文件，将域名解析直接指向 IP 地址来绕过 DNS 的解析，以此解决污染问题。. 三、具体步骤（1）通过https://www.ipaddress.com/查询github的IP地址（2）修改hosts文件，路径C:\\Windows\\System32\\drivers\\etc\\hosts（3）更新本地DNS缓存，cmd中输入：ipconfig /flushdns后回车 修改hosts时可能会提示没有权限，把hosts保存到其他地方后，直接拖回hosts的目录下，提示权限问题，点击继续即可。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"}]},{"title":"爬虫Traceback (most recent call last):异常","slug":"爬虫Traceback (most recent call last)_异常","date":"2020-07-23T11:40:11.811Z","updated":"2020-07-26T09:37:54.461Z","comments":true,"path":"2020/07/23/爬虫Traceback (most recent call last)_异常/","link":"","permalink":"http://yoursite.com/2020/07/23/%E7%88%AC%E8%99%ABTraceback%20(most%20recent%20call%20last)_%E5%BC%82%E5%B8%B8/","excerpt":"","text":"问题描述今天在爬虫的时候经常遇到Traceback (most recent call last):异常，程序写得比较简陋，没有处理异常，导致爬虫程序经常报错停止。经过调试，发现是爬虫网站不稳定导致连接失败。 解决方法123456789101112maxTryNum = 20for tries in range(maxTryNum): try: response = requests.get(urls[i], headers=headers, timeout=60) with open(dir_name + '/' + file_name,'wb') as f: f.write(response.content) except: if tries &lt; (maxTryNum - 1): continue else: print(\"Has tried %d times to access url %s, all failed!\" % (maxTryNum, urls[i])) break","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"记一次Python爬虫入门","slug":"记一次Python爬虫入门","date":"2020-07-22T14:11:45.495Z","updated":"2020-07-26T09:37:44.419Z","comments":true,"path":"2020/07/22/记一次Python爬虫入门/","link":"","permalink":"http://yoursite.com/2020/07/22/%E8%AE%B0%E4%B8%80%E6%AC%A1Python%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/","excerpt":"","text":"今天刚装好python环境，想要练练手。找了网上的教程敲了一个简单的爬虫代码，下载lofter的图片。 程序思路（1）锁定目标网站（2）提取HTML页面代码（3）findall查找图片url（4）保存图片 程序步骤（1）确定目标网站 （2）分析该网页的代码（3）findall查找出所有图片的url，保存到list中（4）遍历list，保存到本地 程序源码12345678910111213141516171819202122232425262728\"\"\"请求网页\"\"\"import timeimport requestsimport reimport os\"\"\"请求头部\"\"\"headers = &#123; 'User-Agent' : 'lofter'&#125;response = requests.get('https://xxx.com/',headers=headers)html = response.text\"\"\"解析网页\"\"\"# 提取网页名，用于图片保存的文件夹名dir_name = re.findall('&lt;a class=\"f-trans\" hidefocus=\"true\" href=\"/\"&gt;(.*?)&lt;/a&gt;',html)[-1]if not os.path.exists(dir_name): os.mkdir(dir_name)# 提取所有图片的urlurls = re.findall('&lt;img src=\"(.*?)\" /&gt;',html)print(urls)\"\"\"保存图片\"\"\"for i in range(len(urls)): # 延迟 time.sleep(1) # 图片的名字 file_name = str(i) response = requests.get(urls[i], headers=headers) with open(dir_name + '/' + file_name + '.jpg','wb') as f: f.write(response.content)","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"个人博客项目总结","slug":"个人博客项目总结","date":"2020-07-17T08:57:52.939Z","updated":"2020-07-26T09:37:27.572Z","comments":true,"path":"2020/07/17/个人博客项目总结/","link":"","permalink":"http://yoursite.com/2020/07/17/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/","excerpt":"","text":"1.前言学习了SSM框架后练手，写这个博客大概花了一个多星期。博客基本功能都有实现，后台代码写地比较简单。前端页面仿造Hexo博主的博客页面（传送门：https://jerryc.me/），由于本人前端技术有限，只能写一个大概的页面。 2.技术总结前端：bootstrap+layui（bootstrap主要用于实现响应式，layui写后台管理系统页面）后台：SpringMVC+Spring+Mybatis（Maven搭建环境）数据库：Mysql 3.主要功能添加文章、管理文章、显示/隐藏文章、添加标签分类、管理标签分类、评论文章、评论管理、分享文章、友链的管理、个人资料更新 4.数据库设计文章表分类表标签表标签-文章映射表评论表友链表用户表 5.项目结构 6.部分页面功能(1)博客首页首页文章列表分页功能用的是layui的分页模块 HTML代码：JS代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;script&gt; window.onload = function() &#123; loadData(); //请求文章数据 getPage(); //分页操作 &#125; var page = 1; //设置首页页码 var limit = 5; //设置一页显示的条数 var count; //总条数 function loadData() &#123; $.ajax(&#123; type : \"post\", url : \"PostController/findByPageDesc\",//对应controller的URL async : false, dataType : 'json', data : &#123; \"curr\" : page, \"nums\" : limit, &#125;, success : function(msg) &#123; count = msg.count; //设置总条数 var html = []; var post = msg.data; for (var i = 0; i &lt; post.length; i++) &#123; html.push('&lt;div class=\" articleboder\"&gt;' + '&lt;div id=\"' + post[i].id +'\" class=\"col-sm-6 col-xs-12 articleimg\" onclick=\"javascript:article(this)\"&gt;' + '&lt;img src=\"./upload/'+post[i].img+'\"/&gt;&lt;/div&gt;' + '&lt;div class=\"col-sm-6 col-xs-12 articleintro\"&gt;' + '&lt;div class=\"hidden-xs articlehidden\"&gt;&lt;/div&gt;' + '&lt;div class=\"visible-xs articlevisible\"&gt;&lt;/div&gt;' + '&lt;div id=\"' + post[i].id + '\" class=\"title\" onclick=\"javascript:article(this)\"&gt;' + post[i].title + '&lt;/div&gt;' + '&lt;div class=\"articledate\"&gt;' + ' &lt;span&gt;&lt;i class=\"fa fa-calendar\" aria-hidden=\"true\"&gt;&lt;/i&gt;&lt;a&gt;' + post[i].timeString + '&lt;/a&gt;&lt;/span&gt;' + ' &lt;span&gt;&lt;a&gt;|&lt;/a&gt;&lt;/span&gt;' + ' &lt;span&gt;&lt;i class=\"fa fa-inbox article-meta__icon\" aria-hidden=\"true\"&gt;&lt;/i&gt;&lt;a&gt;' + post[i].typeString + '&lt;/a&gt;&lt;/span&gt;' + '&lt;/div&gt;' + '&lt;div class=\"intro\"&gt;' + post[i].summary + '&lt;/div&gt;' + '&lt;/div&gt;' + '&lt;/div&gt;'); &#125; $(\".content\").empty().append(html); &#125; &#125;); &#125; function getPage() &#123; layui.use('laypage', function() &#123; var laypage = layui.laypage; //执行一个laypage实例 laypage.render(&#123; elem : 'demo2', //注意，这里的 demo2 是 ID，不用加 # 号 count : count, //数据总数，从服务端得到 limit : limit, //每页条数设置 theme : '#1E9FFF', jump : function(obj, first) &#123; //obj包含了当前分页的所有参数，比如： console.log(obj.curr); //得到当前页，以便向服务端请求对应页的数据。 console.log(obj.limit); //得到每页显示的条数 page = obj.curr; //改变当前页码 limit = obj.limit; //首次不执行 if (!first) &#123; loadData(); //加载数据 &#125; &#125; &#125;); &#125;); &#125; &lt;/script&gt; 后台代码： 123456789101112@RequestMapping(\"/findByPageDesc\") public @ResponseBody String findByPageDesc(Integer curr, Integer nums) throws JsonProcessingException&#123; int pagenum=(curr - 1)*nums; List&lt;Post&gt; posts = postService.findByPageDesc(pagenum, nums); JSONObject object = new JSONObject(); object.put(\"code\", 0); object.put(\"msg\", \"\"); object.put(\"count\", postService.count()); object.put(\"data\", posts); System.out.println(object.toJSONString()); return object.toJSONString(); &#125; (2)随机颜色大小标签HTML代码：JS代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;script&gt; //分页 window.onload = function() &#123; loadData(); //请求数据 label(); &#125; function loadData() &#123; $.ajax(&#123; type : \"post\", url : \"TagController/selectAll\",//对应controller的URL async : false, dataType : 'json', success : function(msg) &#123; var html = []; var tag = msg.data; for (var i = 0; i &lt; tag.length; i++) &#123; html.push('&lt;a href=\"label_detail.jsp?tagid=' + tag[i].id + '\"&gt;' + tag[i].tag + '&lt;/a&gt;'); &#125; $(\".content\").empty().append(html); &#125; &#125;); &#125; function label() &#123; $(document).ready(function() &#123; var obj = $(\"#wrap a\");//获取a标签中的数据 function rand(num) &#123; //parseInt();将字符串转为整数 //Math.random()；生成随机数 return parseInt(Math.random() * num + 1); &#125; function randomcolor() &#123; var str = Math.ceil(Math.random() * 16777215).toString(16); if (str.length &lt; 6) &#123; str = \"0\" + str; &#125; return str; &#125; for (len = obj.length, i = len; i--;) &#123; obj[i].style.left = rand(600) + \"px\";//标签左右间距 obj[i].style.top = rand(400) + \"px\";//标签上下间距 obj[i].className = \"color\" + rand(5); obj[i].style.zIndex = rand(5);//设置元素的堆叠顺序 obj[i].style.fontSize = rand(5) + 18 + \"px\";//随机字体大小这里是18-23 obj[i].style.color = \"#\" + randomcolor();//字体颜色 obj[i].style.padding = rand(15) + \"px\"; &#125; &#125;); &#125;&lt;/script&gt; 后台返回标签的Json字符串 (3)写文章文章内容使用的是百度的ueditor，百度ueditor下载JSP版本，把解压后的文件放进项目目录里，查看官方文档进行配置。 (4)文章管理页面文章管理页面用的是layui的table模块，有编辑、删除和显示（隐藏）三个功能。表格数据渲染：HTML代码： &lt;table id=&quot;test&quot; lay-filter=&quot;test&quot;&gt;&lt;/table&gt; JS代码： 12345678910111213141516&lt;script type=\"text/html\" id=\"toolbarDemo\"&gt; &lt;div class=\"layui-btn-container\"&gt; &lt;button class=\"layui-btn layui-btn-sm\" lay-event=\"getCheckData\"&gt;获取选中行数据&lt;/button&gt; &lt;button class=\"layui-btn layui-btn-sm\" lay-event=\"getCheckLength\"&gt;获取选中数目&lt;/button&gt; &lt;button class=\"layui-btn layui-btn-sm\" lay-event=\"isAll\"&gt;验证是否全选&lt;/button&gt; &lt;/div&gt;&lt;/script&gt; &lt;script type=\"text/html\" id=\"barDemo\"&gt; &lt;a class=\"layui-btn layui-btn-sm layui-bg-blue\" lay-event=\"edit\"&gt;编辑&lt;/a&gt; &lt;a class=\"layui-btn layui-btn-sm layui-btn-danger\" lay-event=\"del\"&gt;删除&lt;/a&gt;&lt;/script&gt;&lt;script id=\"switchTpl\" type=\"text/html\"&gt; &lt;input type=\"checkbox\" name=\"display\" value = &#123;&#123;d.display&#125;&#125; lay-skin=\"switch\" lay-text=\"显示|隐藏\" lay-filter=\"display\" &#123;&#123; d.display == '1' ? 'checked' : '' &#125;&#125;&gt;&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149&lt;script src=\"$&#123;pageContext.request.contextPath&#125;/resources/layui/layui.all.js\"&gt;&lt;/script&gt;&lt;script&gt;//JavaScript代码区域layui.use('element', function()&#123; var element = layui.element; &#125;);//显示或隐藏文章layui.use('form',function()&#123; var form = layui.form form.on('switch(display)', function(obj)&#123; //根据业务判断是开启还是关闭 var state = obj.elem.checked?0:1; //取数据（根据索引table.cache里面的行数据） var index = obj.othis.parents('tr').attr(\"data-index\"); var id = tableData[index].id; $.ajax(&#123; url: '../PostController/display?id='+id+'&amp;display='+state, type: \"post\", dataType:\"json\", success: function(suc) &#123; if(suc.code === 1) &#123; if(suc.msg === 0)&#123; layer.msg(\"文章已隐藏\", &#123; icon: 6 &#125;); &#125;else if(suc.msg === 1)&#123; layer.msg(\"文章已显示\", &#123; icon: 6 &#125;); &#125; &#125; else &#123; layer.msg(\"设置失败，请稍后再试！\", &#123; icon: 5 &#125;); &#125; &#125; &#125;); &#125;);&#125;);var tableData;layui.use('table', function()&#123; var table = layui.table; table.render(&#123; elem: '#test' ,url:'../PostController/findByPage' ,method:'post' ,limits : [5,10,15,20] ,limit : 10 ,request: &#123; pageName: 'curr' ,//页码的参数名称，默认：page limitName: 'nums' //每页数据量的参数名，默认：limit &#125; ,toolbar: '#toolbarDemo' //开启头部工具栏，并为其绑定左侧模板 ,defaultToolbar: ['filter', 'exports', 'print', &#123; //自定义头部工具栏右侧图标。如无需自定义，去除该参数即可 title: '提示' ,layEvent: 'LAYTABLE_TIPS' ,icon: 'layui-icon-tips' &#125;] ,title: '用户数据表' ,cols: [[ &#123;type: 'checkbox', fixed: 'left'&#125; ,&#123;field:'id', title:'ID', width:70, unresize: true, sort: true&#125; ,&#123;field:'title', title:'标题',width:328&#125; ,&#123;field:'typeString', title:'分类',width:158&#125; ,&#123;field:'clickhit', title:'点击数',width:125, sort: true&#125; ,&#123;field:'replyhit', title:'评论数',width:125, sort: true&#125; ,&#123;field:'timeString', title:'发表时间',width:188, sort: true&#125; ,&#123;field:'display', title:'显示状态',width:120,templet:\"#switchTpl\"&#125; ,&#123;fixed: '', title:'操作', fixed: 'right', width:132, toolbar: '#barDemo'&#125; ]] ,page: true ,id:\"tableIns\" ,done:function()&#123; tableData = table.cache.tableIns; &#125; &#125;); //头工具栏事件 table.on('toolbar(test)', function(obj)&#123; var checkStatus = table.checkStatus(obj.config.id); switch(obj.event)&#123; case 'getCheckData': var data = checkStatus.data; layer.alert(JSON.stringify(data)); break; case 'getCheckLength': var data = checkStatus.data; layer.msg('选中了：'+ data.length + ' 个'); break; case 'isAll': layer.msg(checkStatus.isAll ? '全选': '未全选'); break; //自定义头工具栏右侧图标 - 提示 case 'LAYTABLE_TIPS': layer.alert('这是工具栏右侧自定义的一个图标按钮'); break; &#125;; &#125;); //监听行工具事件 table.on('tool(test)', function(obj)&#123; var data = obj.data ,layEvent = obj.event; //获得 lay-event 对应的值 console.log(obj) switch(layEvent)&#123; case 'del': var delIndex = layer.confirm('真的删除\"' + data.title + '\"吗?', function(delIndex) &#123; $.ajax(&#123; url: '../PostController/delete?id='+data.id, type: \"post\", dataType:\"json\", success: function(suc) &#123; if(suc.code === 1) &#123; obj.del(); //删除对应行（tr）的DOM结构，并更新缓存 layer.close(delIndex); console.log(delIndex); layer.msg(\"删除成功\", &#123; icon: 1 &#125;); &#125; else &#123; layer.msg(\"删除失败\", &#123; icon: 5 &#125;); &#125; &#125; &#125;); layer.close(delIndex); &#125;); break; case 'edit': /* $.ajax(&#123; url: '../PostController/editPost?id='+data.id, type: \"get\" &#125;); */ window.location.href=\"../PostController/editPost?id=\"+data.id; break; &#125; &#125;);&#125;);&lt;/script&gt; 后台查询、删除、显示（隐藏）文章的Controller省略 (5)图片上传功能和回显“我的友链”和“基本资料”页面都有图片上传，用的是layui的文件上传功能。图书上传成功后，前端页面会回显图片。HTML代码：JS代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;script src=\"$&#123;pageContext.request.contextPath&#125;/resources/layui/layui.all.js\"&gt;&lt;/script&gt;&lt;script&gt;//JavaScript代码区域layui.use('element', function()&#123; var element = layui.element; &#125;);window.onload= function () &#123; loadImg();&#125;layui.use('upload', function()&#123; var upload = layui.upload; //普通图片上传 upload.render(&#123; elem: '#test1' ,url: '../UserController/uploadImg' ,accept: 'images' ,acceptMime: 'image/*' ,size: '1024*5' ,before: function(obj)&#123; //预读本地文件示例，不支持ie8 obj.preview(function(index, file, result)&#123; $('#demo1').attr('src', result); //图片链接（base64） &#125;); &#125; ,done: function(res, input)&#123; layer.msg('头像上传成功',&#123;icon:6&#125;); console.log(res); //如：&#123;\"code\":0 ,\"msg\":\"\",\"url\":\"http://cdn.abc.com/123.jpg\"'&#125; document.getElementById(\"myimg\").innerHTML=res.name; &#125;&#125;);&#125;);function loadImg()&#123; $.ajax(&#123; type:\"post\", url:\"../UserController/photo\",//对应controller的URL dataType: 'json', success:function(msg)&#123; document.getElementById('demo1').src=msg.name; &#125; &#125;); &#125;&lt;/script&gt; (6)页面加载动画加载动画并不是真的会等待页面数据加载完成后才隐藏，只是等待1000毫秒后隐藏。HTML代码：JS代码： 1234567&lt;script&gt; window.onload = function() &#123; setTimeout(function()&#123; siteLoading.classList.remove('active') &#125;,1000);&#125;&lt;/script&gt; CSS样式： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758.wrapper &#123; height: 200px; width: 200px; border: 1px solid #fff; /* 将圆形动画定位到正中 */ position: relative; &#125; .wrapper::before,.wrapper::after&#123; content: ''; height: 10px; width: 10px; background-color: black; border-radius: 100%; /* 将圆形动画定位到正中 */ position: absolute; left: 0; top: 0; bottom: 0; right: 0; margin: auto; animation: dada 2s linear infinite;&#125; .wrapper::after &#123; animation-delay: 1s;&#125; @keyframes dada &#123; 0% &#123; height: 0px; width: 0px; opacity: 1; &#125; 100% &#123; height: 100px; width: 100px; opacity: 0; &#125;&#125;.loading &#123; display: none; background-color: #fff; position: fixed; top: 0; left: 0; height: 100%; width: 100%; z-index: 999; justify-content: center; align-items: center; &#125; .loading.active &#123; display: flex;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/tags/SSM/"}]},{"title":"springmvc使用PathVariable路径匹配问题","slug":"springmvc使用@PathVariable路径匹配问题","date":"2020-06-16T10:32:53.158Z","updated":"2020-07-26T09:36:24.568Z","comments":true,"path":"2020/06/16/springmvc使用@PathVariable路径匹配问题/","link":"","permalink":"http://yoursite.com/2020/06/16/springmvc%E4%BD%BF%E7%94%A8@PathVariable%E8%B7%AF%E5%BE%84%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98/","excerpt":"","text":"1、问题今天学了springmvc的jsp页面传值 &lt;a href=”${pageContext.request.contextPath }/detail1?id=10001” &gt;通过参数传递ID&lt;/a&gt; &lt;a href=”${pageContext.request.contextPath }/detail2/10001.html” &gt;路径变量@pathvariable在路径上传递ID&lt;/a&gt; 通过参数传递数据，数据会直接出现在地址栏上，信息暴露不安全。而通过路径变量可以加上后缀，相对安全一点。这是代码结构，jt.jsp传参进入detail2这个controller，controller在控制台输出jsp传过来的参数后重定向到jt.jsp（jt.jsp中有引用到css、js和图片）。运行程序后，重定向的时候发现控制台成功打印jsp传进的参数，但是重定向后，页面的样式和图片丢失了。在springmvc的配置文件里有配置静态资源访问查看浏览器控制台发现，找不到样式文件和图片。文件的路径前多了/testpathvariable找不到文件 2、解决方法在网上找到的问题原因是因为引用静态文件的时候使用了相对路径。解决方法就是把引用修改为绝对路径。 123&lt;link rel=\"stylesheet\" href=\"$&#123;pageContext.request.contextPath &#125;/css/bootstrap.min.css\" type=\"text/css\" /&gt;&lt;link rel=\"stylesheet\" href=\"$&#123;pageContext.request.contextPath &#125;/css/jt.css\" type=\"text/css\" /&gt;&lt;script type=\"text/javascript\" src=\"$&#123;pageContext.request.contextPath &#125;/js/jt.js\" &gt;&lt;/script&gt;","categories":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"}]},{"title":"JSTL和EL表达式遍历List数组","slug":"JSTL和EL表达式遍历List数组","date":"2020-06-15T16:43:04.201Z","updated":"2020-07-26T09:36:08.362Z","comments":true,"path":"2020/06/16/JSTL和EL表达式遍历List数组/","link":"","permalink":"http://yoursite.com/2020/06/16/JSTL%E5%92%8CEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%81%8D%E5%8E%86List%E6%95%B0%E7%BB%84/","excerpt":"","text":"JSTL的jar包下载：https://share.weiyun.com/zDcHu70Q1、导包将JSTL的jar包放进web项目的lib文件夹下2、在jsp页面中引入JSTL的核心标签库1&lt;%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %&gt; 3、使用foreach遍历List数组123&lt;c:forEach items=\"$&#123;persons&#125;\" var=\"person\"&gt; $&#123;person&#125;|&lt;/c:forEach&gt; items使用EL表达式拿到servlet传过来的数组var指定遍历数组的值，然后再用EL表达式取得var中的值。4、效果","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JSTL","slug":"JSTL","permalink":"http://yoursite.com/tags/JSTL/"},{"name":"EL表达式","slug":"EL表达式","permalink":"http://yoursite.com/tags/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"bootstrap快速开发响应式页面","slug":"bootstrap快速开发响应式页面","date":"2020-06-15T11:06:51.768Z","updated":"2020-07-26T09:35:31.744Z","comments":true,"path":"2020/06/15/bootstrap快速开发响应式页面/","link":"","permalink":"http://yoursite.com/2020/06/15/bootstrap%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%E5%93%8D%E5%BA%94%E5%BC%8F%E9%A1%B5%E9%9D%A2/","excerpt":"","text":"最近在用 Bootstrap做网页，Bootstrap提供的样式和组件很多，开发简单的页面也基本够用了。虽然使用里面的样式可能不能完全满足需求，但是可以在Bootstrap提供的样式基础上，自己重新写属性覆盖，也比之前的CSS完全靠手写高效得多了。还有一点就是使用Bootstrap开发响应式页面真的非常方便，不用去自己写媒体查询，不用设置页面在各种设备下的样式。Bootstrap已经提供了相应的类，只需要直接引用就可以。 1、栅格系统栅格系统用于通过一系列的行（row）与列（column）的组合来创建页面布局，内容就可以放入这些创建好的布局中。Bootstrap 栅格系统的把列分为.col-xs-、.col-sm-、.col-md-、.col-lg-，分别对应手机(&lt;768px)、平板(≥768px)、中等屏幕电脑(≥992px)和大屏幕电脑(≥1200px)。其中出现的这些像素称为临界点，每当浏览器大小或屏幕尺寸从一个临界点到达另一个临界点时，相应的 CSS 类就会起作用，页面布局就会发生变化。列数的最大值为12列，大于12列会自动换行。详见下图：例如我们想给这个页面设置响应式，可以先在大屏幕和中等屏幕下给左边设置9列，右边设置3列。当屏幕变成小屏幕和超小屏幕时，把左边和右边都设置成12列，这时候右边的内容就会被顶到左边内容的底部。 2、容器在Bootstrap中页面内容和栅格系统需要包裹一个 .container 容器。Bootstrap提供了两个类。注意，由于 padding 等属性的原因，这两种容器类不能互相嵌套。 ① .container 类用于固定宽度并支持响应式布局的容器。 123&lt;div class=\"container\"&gt; ...&lt;/div&gt; 可以在CSS中使用媒体查询改写容器的最大宽度 123456/* 修改container的最大宽度1280 */@media screen and (min-width: 1280px)&#123; .container&#123; width:1280px; &#125;&#125; ② .container-fluid 类用于 100% 宽度，占据全部视口（viewport）的容器。 123&lt;div class=\"container-fluid\"&gt; ...&lt;/div&gt; 3、Bootstrap安装①最简单的方式是直接在网页中引用内容分发网络（CDN）提供的 Bootstrap。 12345678&lt;!-- 最新版本的 Bootstrap 核心 CSS 文件 --&gt;&lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\" crossorigin=\"anonymous\"&gt;&lt;!-- 可选的 Bootstrap 主题文件（一般不用引入） --&gt;&lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap-theme.min.css\" integrity=\"sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp\" crossorigin=\"anonymous\"&gt;&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js\" integrity=\"sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; ②也可以下载Bootstrap压缩包，解压后导入项目，直接引用。Bootstrap目录结构：bootstrap/├── css/│ ├── bootstrap.css│ ├── bootstrap.css.map│ ├── bootstrap.min.css│ ├── bootstrap-theme.css│ ├── bootstrap-theme.css.map│ └── bootstrap-theme.min.css├── js/│ ├── bootstrap.js│ └── bootstrap.min.js└── fonts/├── glyphicons-halflings-regular.eot├── glyphicons-halflings-regular.svg├── glyphicons-halflings-regular.ttf├── glyphicons-halflings-regular.woff└── glyphicons-halflings-regular.woff2 这里写响应式页面只需要用到css，只要引入bootstrap.min.css 4、实战 Bootstrap版本：v3.3.7 编辑器：vscode 先设置一个容器，然后在容器里放上左边的文章列表和右边的侧边栏（这里在容器内又放了一个row是因为Bootstrap的col--类默认会有左右15px的padding值，放一个row可以去掉默认的padding值）然后给左边的文章列表设置中等屏幕下col-md-9占9列，小屏幕下col-sm-12占12列（大屏幕包括在中等屏幕，可以直接省略col-lg-9。超小屏幕同理）。给右边的侧边栏设置中等屏幕下col-md-3占3列，小屏幕下col-sm-12占12列（大屏幕包括在中等屏幕，可以直接省略col-lg-9。超小屏幕同理） 实现效果：大屏幕中等屏幕：小屏幕：超小屏幕 5、响应式显示和隐藏Bootstrap还提供了响应式显示和隐藏工具类：hidden-* (在指定设备lg、md、sm、xs下隐藏)visible-* (在指定设备lg、md、sm、xs下显示)具体实现如下 1234&lt;!-- 隐藏域 （在小屏幕下隐藏）--&gt;&lt;div class=\"hidden-xs\"&gt;&lt;/div&gt;&lt;!-- 显示域 （在大屏幕下显示）--&gt;&lt;div class=\"visible-lg\"&gt;&lt;/div&gt;","categories":[{"name":"Html","slug":"Html","permalink":"http://yoursite.com/categories/Html/"}],"tags":[{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/tags/Bootstrap/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"记录Hexo加github搭建博客过程中遇见的问题及解决方法","slug":"Hexo加github搭建博客过程中遇见的问题及解决方法","date":"2020-06-14T14:47:24.647Z","updated":"2020-07-26T09:35:49.031Z","comments":true,"path":"2020/06/14/Hexo加github搭建博客过程中遇见的问题及解决方法/","link":"","permalink":"http://yoursite.com/2020/06/14/Hexo%E5%8A%A0github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","excerpt":"","text":"前情提要使用Hexo和github搭建免费个人博客前提是先要安装好git、Node.js和Hexo。环境安装完成后，通过git在本地搭建Hexo博客，最后将博客托管到github即可。 一、git的安装出现的问题1、官网下载git速度很慢，使用百度网盘下载：链接: https://pan.baidu.com/s/1FcsQYR7cFNme7Y77pw4xiw 提取码: ftrp 2、配置SSH KEY时用命令 1ssh -T git@github.com 查看git认证是否配置成功时报错 “The authenticity of host &#39;github.com (13.250.117.223)&#39; can&#39;t be established.” 123456$ ssh -T git@github.com The authenticity of host 'github.com (13.250.177.223)' can't be established. RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. Are you sure you want to continue connecting (yes/no)? Warning: Permanently added 'github.com,13.250.177.223' (RSA) to the list of known hosts. Permission denied (publickey). Are you sure you want to continue connecting (yes/no)? #这里直接输入yes回车 3、出现fatal:Could not read from remote repository.①如果没有在github的Settings中添加SHH KEY，去github添加即可。②如果在github中已经添加SHH KEY，把.shh文件夹中的id_rsa和id_rsa.pub两个文件删除，重新配置SHH KEY并添加到github就可以了。 二、Node.js出现的问题1、安装cnpm使用国内镜像、解决卡顿①以管理员身份运行命令提示符②换成阿里源下载 1npm config set registry https://registry.npm.taobao.org ③验证命令，返回http://registry.npm.taobao.org，则说明镜像配置成功。 1npm config get registry ④安装cnpm 1npm install -g cnpm --registry=https://registry.npm.taobao.org 2、npm一直停在”checking installable status”可能是旧的npm缓存与项目冲突或者修改过仓库源（阿里源之类的），解决的方法：① 1sudo npm cache clean ② 1npm config set registry https://registry.npm.taobao.org 三、安装Hexo和搭建本地Hexo博客1、执行命令hexo server，提示：Usage :hexo…提示找不到该指令在本地生成hexo模板后在输入hexo server启动服务器时，提示找不到server指令。这是因为Hexo3.0把服务器独立成了个别模块，所以不能直接使用hexo server，必须先安装hexo-server才可以使用。安装命令： 1$ npm install hexo-server --save 2、出现”Cannot GET/XXX”错误在Hexo博客中，出现Cannot GET/xxx错误便意味着xxx文件未被找到。Cannot GET/xxx错误本质是hexo server返回的一个404错误。①判断博客的public目录下xxx文件是否存在。（我的错误是 Cannot GET /，因此在public目录下寻找index.html是否存在。）②如果说index.html不存在，那么执行hexo c，hexo g重新生成一次，回到步骤1。③步骤2执行完后index.html仍不存在，执行npm audit fix，查看是否少了什么组件，通过npm install hexo-xxx-xxx安装即可。（我的hexo缺少了hexo-generator-index组件，因此执行npm install hexo-generator-index即可）④步骤3完成之后，执行hexo c，hexo g重新生成静态文件。 3、No Layout:index.html当使用hexo g命令时，编译过程会出现警告和错误信息。把错误信息中的hexo插件和组件安装完，即可解决问题。①使用命令查看hexo插件和组件的安装情况 12npm ls //查看hexo插件安装情况npm audit fix //查看hexo组件的安装情况 ②通过install命令安装缺失的包和组件 1npm install xxx --save //xxx为插件和组件名 如果安装完插件和组件，重新执行hexo g命令没有报错。而在启动Hexo服务器的时候页面还是空白的，查看博客目录下themes目录下的主题目录是否为空，为空的话是因为在使用hexo init命令在本地生成hexo模板的时候缺少组件或者插件，导致模板生成失败。在安装完插件或组件后，删除博客目录下的文件，重新使用hexo init命令生成模板。配置后打开http://localhost:4000/就不是空白了。","categories":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"标签随机文字颜色和字体大小的实现方法","slug":"标签随机文字颜色和字体大小的实现方法","date":"2020-06-14T14:47:07.930Z","updated":"2020-07-26T09:37:05.271Z","comments":true,"path":"2020/06/14/标签随机文字颜色和字体大小的实现方法/","link":"","permalink":"http://yoursite.com/2020/06/14/%E6%A0%87%E7%AD%BE%E9%9A%8F%E6%9C%BA%E6%96%87%E5%AD%97%E9%A2%9C%E8%89%B2%E5%92%8C%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/","excerpt":"","text":"先上效果图：实现代码： 12345678910111213141516171819202122232425262728&lt;script type=\"text/javascript\"&gt; $(document).ready(function()&#123; var obj=$(\"#wrap a\");//获取a标签中的数据 function rand(num)&#123; //parseInt();将字符串转为整数 //Math.random()；生成随机数 return parseInt(Math.random()*num+1); &#125; function randomcolor()&#123; var str=Math.ceil(Math.random()*16777215).toString(16); if(str.length&lt;6)&#123; str=\"0\"+str; &#125; return str; &#125; for(len=obj.length,i=len;i--;)&#123; obj[i].style.left=rand(600)+\"px\";//标签左右间距 obj[i].style.top=rand(400)+\"px\";//标签上下间距 obj[i].className=\"color\"+rand(5); obj[i].style.zIndex=rand(5);//设置元素的堆叠顺序 obj[i].style.fontSize=rand(5)+18+\"px\";//随机字体大小这里是18-23 obj[i].style.color=\"#\"+randomcolor();//字体颜色 obj[i].style.padding=rand(15)+\"px\"; &#125; &#125;);&lt;/script&gt; html中直接在div设置id=”wrap”，用&lt;c:forEach&gt;遍历标签。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"安卓Service和Broadcast实现简单的音乐播放器","slug":"安卓Service和Broadcast实现简单的音乐播放器","date":"2020-06-07T12:07:40.699Z","updated":"2020-07-26T09:36:42.940Z","comments":true,"path":"2020/06/07/安卓Service和Broadcast实现简单的音乐播放器/","link":"","permalink":"http://yoursite.com/2020/06/07/%E5%AE%89%E5%8D%93Service%E5%92%8CBroadcast%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/","excerpt":"","text":"做实验的时候使用Service和Broadcast实现了一个功能较为简单的音乐播放器，可以对音乐进行播放、暂停和停止。主要思路：1、使用Service在后台播放音乐2、Broadcast发送广播通知Activity更改界面程序运行界面： 图1 播放界面 图2 暂停界面 图3 停止界面 实现代码： 1、布局界面XML如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;androidx.appcompat.widget.Toolbar android:id=\"@+id/musicbar\" android:layout_width=\"match_parent\" android:layout_height=\"60dp\" android:background=\"?attr/colorPrimary\" android:minHeight=\"?attr/actionBarSize\" android:theme=\"?attr/actionBarTheme\" app:navigationIcon=\"@drawable/logo\" app:titleTextColor=\"@color/white\" /&gt; &lt;View android:id=\"@+id/view\" android:layout_width=\"match_parent\" android:layout_height=\"100dp\" /&gt; &lt;ImageView android:id=\"@+id/photo\" android:layout_width=\"250dp\" android:layout_height=\"250dp\" android:layout_gravity=\"center\" android:layout_marginBottom=\"20dp\" app:srcCompat=\"@drawable/qielogo\" /&gt; &lt;TextView android:id=\"@+id/musictext\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" android:layout_marginBottom=\"100dp\" android:text=\"暂无播放音乐\" android:textSize=\"28dp\" /&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"@color/white\" android:orientation=\"horizontal\"&gt; &lt;ImageButton android:id=\"@+id/start\" android:layout_width=\"90dp\" android:layout_height=\"90dp\" android:layout_weight=\"1\" android:background=\"@color/white\" android:scaleType=\"centerInside\" app:srcCompat=\"@drawable/start\" /&gt; &lt;ImageButton android:id=\"@+id/stop\" android:layout_width=\"90dp\" android:layout_height=\"90dp\" android:layout_weight=\"1\" android:background=\"@color/white\" android:scaleType=\"centerInside\" app:srcCompat=\"@drawable/stop\" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 2、主Acitivy如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package com.example.test6;import androidx.appcompat.app.AppCompatActivity;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.content.IntentFilter;import android.os.Bundle;import android.util.Log;import android.view.View;import android.widget.ImageButton;import android.widget.ImageView;import android.widget.TextView;public class Music extends AppCompatActivity &#123; TextView musictext; ImageView photo; ImageButton startbutton; Integer state = 2; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_music); IntentFilter inf = new IntentFilter(); inf.addAction(\"com.user.action\"); registerReceiver(broad,inf); musictext = findViewById(R.id.musictext); photo = findViewById(R.id.photo); startbutton = findViewById(R.id.start); ImageButton stopbutton = findViewById(R.id.stop); startbutton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; switch (state)&#123; case 1: state = 2; break; default: state = 1; break; &#125; Log.v(\"当前状态\",\"1\"); Intent intent = new Intent(Music.this,MusicService.class); intent.putExtra(\"action\",state); startService(intent); Log.v(\"intent传值\",\"1\"); &#125; &#125;); stopbutton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(Music.this,MusicService.class); stopService(intent); &#125; &#125;); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); unregisterReceiver(broad); &#125; public BroadcastReceiver broad = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; int i = intent.getIntExtra(\"action\",-1); switch(i)&#123; case 1: musictext.setText(\"China-X\"); photo.setImageResource(R.drawable.yjtp); startbutton.setImageResource(R.drawable.pause); break; case 2: startbutton.setImageResource(R.drawable.start); musictext.setText(\"音乐暂停\"); break; case 3: state = 3; musictext.setText(\"暂无播放音乐\"); photo.setImageResource(R.drawable.qielogo); startbutton.setImageResource(R.drawable.start); break; &#125; &#125; &#125;;&#125; 3、Service类如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.example.test6;import android.app.Service;import android.content.Intent;import android.media.MediaPlayer;import android.os.IBinder;import android.util.Log;public class MusicService extends Service &#123; public IBinder onBind(Intent intent)&#123; return null; &#125; private MediaPlayer mp; public void onCreate()&#123; super.onCreate(); &#125; public void onStart(Intent intent,int startId)&#123; super.onStart(intent,startId); int i = intent.getIntExtra(\"action\",0); if(i==1)&#123; if(null==mp) &#123; mp = MediaPlayer.create(this, R.raw.mymusic); mp.setOnCompletionListener(new MediaPlayer.OnCompletionListener() &#123; @Override public void onCompletion(MediaPlayer mp) &#123; stopSelf(); &#125; &#125;); &#125; mp.start(); &#125;else if(i==2)&#123; if(mp!=null&amp;&amp;mp.isPlaying())&#123; mp.pause(); &#125; &#125; Log.v(\"zhuangtai\",String.valueOf(i)); Intent in = new Intent(\"com.user.action\"); in.putExtra(\"action\",i); sendBroadcast(in); &#125; public void onDestroy()&#123; super.onDestroy(); mp.stop(); Intent in = new Intent(\"com.user.action\"); in.putExtra(\"action\",3); sendBroadcast(in); &#125;&#125;","categories":[{"name":"移动开发","slug":"移动开发","permalink":"http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"},{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-05-02T06:40:42.967Z","updated":"2020-10-02T06:24:37.968Z","comments":true,"path":"2020/05/02/hello-world/","link":"","permalink":"http://yoursite.com/2020/05/02/hello-world/","excerpt":"","text":"👻 2020-10-01 博客使用github图床和jsDelivr CDN加速 👻 2020-07-26 博客由原来的托管github，同时托管到coding 接入域名shadowx.vip 博客所有图片使用imgchr图床CDN加速 👻 2020-07-24 添加Valine评论系统 新增“图片”页面 👻 2020-06-07 博客更换Butterfly主题 👻 2020-05-02 博客更换archer主题 👻 2020-05-02 shadow博客搭建完成！！！","categories":[],"tags":[{"name":"does","slug":"does","permalink":"http://yoursite.com/tags/does/"}]}],"categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"},{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"},{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/categories/SSM/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://yoursite.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"},{"name":"Html","slug":"Html","permalink":"http://yoursite.com/categories/Html/"},{"name":"移动开发","slug":"移动开发","permalink":"http://yoursite.com/categories/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"},{"name":"Valine","slug":"Valine","permalink":"http://yoursite.com/tags/Valine/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"},{"name":"SSM","slug":"SSM","permalink":"http://yoursite.com/tags/SSM/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"},{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"http://yoursite.com/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"JSTL","slug":"JSTL","permalink":"http://yoursite.com/tags/JSTL/"},{"name":"EL表达式","slug":"EL表达式","permalink":"http://yoursite.com/tags/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"http://yoursite.com/tags/Bootstrap/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"移动开发","slug":"移动开发","permalink":"http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91/"},{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"does","slug":"does","permalink":"http://yoursite.com/tags/does/"}]}